namespace globalThis {
    function setImmediate(cb: (...arguments: Array<any>) => void, ...arguments: Array<any>): number
    function clearImmediate(timer: number): void
}
declare namespace Duktape {
    const version: number
    const env: string

    export class Thread {
        constructor(yielder: (v?: any) => void);
        static resume<T>(t: Thread, v?: any): T
        static yield<T>(v?: any): T
    }
}

namespace ejs {
    type BufferData = Uint8Array | Uint16Array | Uint32Array |
        Uint8ClampedArray |
        Int8Array | Int16Array | Int32Array |
        ArrayBuffer
    /**
     * target os name
     */
    const os: string
    /**
     * target arch name
     */
    const arch: string
    /**
     * script version
     */
    const version: number
    /**
     * gcc version
     */
    const gcc: string | undefined
    /**
     * is the target platform system 32 bit or 64 bit?
     */
    const bits = 32 | 64
    /**
     * process startup parameters
     */
    const args: Array<string>
    interface ErrorOptions {
        cause?: unknown;
    }
    /**
     * extends globalThis.Error, with a cause attribute recording the cause of the error, usually a number error code
     */
    class Error extends globalThis.Error {
        constructor(message?: string, options?: ErrorOptions)
        cause?: unknown
    }

    /**
     * os error returned by c api
     */
    class OsError extends Error {
        constructor(readonly errno: number, message?: string)
        get errnoString(): string
    }
    /**
     * es5 compatibility function code generated by tsc. 
     */
    function __values(...a: Array<any>): any
    /**
     * es5 compatibility function code generated by tsc. 
     */
    function __extends(...a: Array<any>): any
    /**
     * es5 compatibility function code generated by tsc. 
     */
    function __awaiter(...a: Array<any>): any
    /**
     * es5 compatibility function code generated by tsc. 
     */
    function __generator(...a: Array<any>): any
    /**
     * es5 compatibility function code generated by tsc. 
     */
    function __read(...a: Array<any>): any
    /**
     * es5 compatibility function code generated by tsc. 
     */
    function __spreadArray(...a: Array<any>): any

    /**
     * exit process
     */
    function exit(code: number): never
    /**
     * Compare bytes for equality
     */
    function equal(a: string | ArrayBufferLike, b: string | ArrayBufferLike): boolean
    /**
     * bytes copy
     */
    function copy(dst: BufferData, src: BufferData | string): number
    /**
     * 
     * return bytes length of v
     */
    function len(v: string | BufferData): number
    /**
     * if is duk buffer data return true else return false
     */
    function isBufferData(v: any): boolean

    interface ThreadsStat {
        /**
         * The maximum number of idle threads allowed
         */
        workerIdle?: number
        /**
         * The maximum number of worker threads allowed
         */
        workerMax?: number
        /**
         * The number of current threads
         */
        worker: number
        /**
         * The number of current idle threads
         */
        idle: number
        /**
         * The number of current producer
         */
        producer: number
        /**
         * The number of current consumer
         */
        consumer: number
        /**
         * The number of current task
         */
        task: number
    }
    /**
     * If the thread pool has been created, return statistics
     */
    function threadsStat(): ThreadsStat | undefined
    interface ThreadsSetOptions {
        /**
         * The maximum number of idle threads allowed
         */
        workerIdle: number
        /**
         * The maximum number of worker threads allowed
         */
        workerMax: number
    }
    /**
     * 
     * Modify the thread pool settings and create the thread pool if it has not been created yet
     */
    function threadsSet(opts?: ThreadsSetOptions): void
}
/**
 * Provides direct encoding support for binary data
 */
declare module "ejs/encoding/binary" {
    /**
     * A ByteOrder specifies how to convert Uint8Array into
     * 16-, 32-, or 64-bit unsigned integers.
     */
    export interface ByteOrder {
        /**
         * Gets the Uint8 value at the specified byte offset from the start of the buffer. There is
         * no alignment constraint; multi-byte values may be fetched from any offset.
         * @param buffer The buffer to read from
         * @param byteOffset The place in the buffer at which the value should be retrieved.
         */
        getUint8(buffer: ejs.BufferData, byteOffset: number): number
        /**
         * Gets the Uint16 value at the specified byte offset from the start of the buffer. There is
         * no alignment constraint; multi-byte values may be fetched from any offset.
         * @param buffer The buffer to read from
         * @param byteOffset The place in the buffer at which the value should be retrieved.
         * @param littleEndian If false or undefined, a big-endian value should be read.
         */
        getUint16(buffer: ejs.BufferData, byteOffset: number): number
        /**
         * Gets the Uint32 value at the specified byte offset from the start of the buffer. There is
         * no alignment constraint; multi-byte values may be fetched from any offset.
         * @param buffer The buffer to read from
         * @param byteOffset The place in the buffer at which the value should be retrieved.
         * @param littleEndian If false or undefined, a big-endian value should be read.
         */
        getUint32(buffer: ejs.BufferData, byteOffset: number): number
        /**
         * Gets the Uint64 value at the specified byte offset from the start of the buffer. There is
         * no alignment constraint; multi-byte values may be fetched from any offset.
         * @param buffer The buffer to read from
         * @param byteOffset The place in the buffer at which the value should be retrieved.
         * @param littleEndian If false or undefined, a big-endian value should be read.
         * @returns If it is within a safe integer that can be represented by js, number is returned. Otherwise, it is returned in the form of a string.
         */
        getUint64(buffer: ejs.BufferData, byteOffset: number): number | string
        /**
         * Stores an Uint8 value at the specified byte offset from the start of the buffer.
         * @param buffer The buffer to write to
         * @param byteOffset The place in the buffer at which the value should be set.
         * @param value The value to set. If a string is passed in, strconv.parseUint(value,0,8) is automatically used to convert it to a number.
         */
        setUint8(buffer: ejs.BufferData, byteOffset: number, value: number | string): void
        /**
         * Stores an Uint16 value at the specified byte offset from the start of the buffer.
         * @param buffer The buffer to write to
         * @param byteOffset The place in the buffer at which the value should be set.
         * @param value The value to set. If a string is passed in, strconv.parseUint(value,0,16) is automatically used to convert it to a number.
         * @param littleEndian If false or undefined, a big-endian value should be written.
         */
        setUint16(buffer: ejs.BufferData, byteOffset: number, value: number | string): void
        /**
         * Stores an Uint32 value at the specified byte offset from the start of the buffer.
         * @param buffer The buffer to write to
         * @param byteOffset The place in the buffer at which the value should be set.
         * @param value The value to set. If a string is passed in, strconv.parseUint(value,0,32) is automatically used to convert it to a number.
         * @param littleEndian If false or undefined, a big-endian value should be written.
         */
        setUint32(buffer: ejs.BufferData, byteOffset: number, value: number | string): void
        /**
         * Stores an Uint16 value at the specified byte offset from the start of the buffer.
         * @param buffer The buffer to write to
         * @param byteOffset The place in the buffer at which the value should be set.
         * @param value The value to set. If a string is passed in, strconv.parseUint(value,0,64) is automatically used to convert it to a number.
         * @param littleEndian If false or undefined, a big-endian value should be written.
         */
        setUint64(buffer: ejs.BufferData, byteOffset: number, value: number | string): void
        /**
         * Gets the Int8 value at the specified byte offset from the start of the buffer. There is
         * no alignment constraint; multi-byte values may be fetched from any offset.
         * @param buffer The buffer to read from
         * @param byteOffset The place in the buffer at which the value should be retrieved.
         */
        getInt8(buffer: ejs.BufferData, byteOffset: number): number
        /**
         * Gets the Int16 value at the specified byte offset from the start of the buffer. There is
         * no alignment constraint; multi-byte values may be fetched from any offset.
         * @param buffer The buffer to read from
         * @param byteOffset The place in the buffer at which the value should be retrieved.
         * @param littleEndian If false or undefined, a big-endian value should be read.
         */
        getInt16(buffer: ejs.BufferData, byteOffset: number): number
        /**
         * Gets the Int32 value at the specified byte offset from the start of the buffer. There is
         * no alignment constraint; multi-byte values may be fetched from any offset.
         * @param buffer The buffer to read from
         * @param byteOffset The place in the buffer at which the value should be retrieved.
         * @param littleEndian If false or undefined, a big-endian value should be read.
         */
        getInt32(buffer: ejs.BufferData, byteOffset: number): number
        /**
         * Gets the Int64 value at the specified byte offset from the start of the buffer. There is
         * no alignment constraint; multi-byte values may be fetched from any offset.
         * @param buffer The buffer to read from
         * @param byteOffset The place in the buffer at which the value should be retrieved.
         * @param littleEndian If false or undefined, a big-endian value should be read.
         * @returns If it is within a safe integer that can be represented by js, number is returned. Otherwise, it is returned in the form of a string.
         */
        getInt64(buffer: ejs.BufferData, byteOffset: number): number | string
        /**
         * Stores an Int8 value at the specified byte offset from the start of the buffer.
         * @param buffer The buffer to write to
         * @param byteOffset The place in the buffer at which the value should be set.
         * @param value The value to set. If a string is passed in, strconv.parseInt(value,0,8) is automatically used to convert it to a number.
         */
        setInt8(buffer: ejs.BufferData, byteOffset: number, value: number | string): void
        /**
         * Stores an Int16 value at the specified byte offset from the start of the buffer.
         * @param buffer The buffer to write to
         * @param byteOffset The place in the buffer at which the value should be set.
         * @param value The value to set. If a string is passed in, strconv.parseInt(value,0,16) is automatically used to convert it to a number.
         * @param littleEndian If false or undefined, a big-endian value should be written.
         */
        setInt16(buffer: ejs.BufferData, byteOffset: number, value: number | string): void
        /**
         * Stores an Int32 value at the specified byte offset from the start of the buffer.
         * @param buffer The buffer to write to
         * @param byteOffset The place in the buffer at which the value should be set.
         * @param value The value to set. If a string is passed in, strconv.parseInt(value,0,32) is automatically used to convert it to a number.
         * @param littleEndian If false or undefined, a big-endian value should be written.
         */
        setInt32(buffer: ejs.BufferData, byteOffset: number, value: number | string): void
        /**
         * Stores an Int64 value at the specified byte offset from the start of the buffer.
         * @param buffer The buffer to write to
         * @param byteOffset The place in the buffer at which the value should be set.
         * @param value The value to set. If a string is passed in, strconv.parseInt(value,0,64) is automatically used to convert it to a number.
         * @param littleEndian If false or undefined, a big-endian value should be written.
         */
        setInt64(buffer: ejs.BufferData, byteOffset: number, value: number | string): void
    }
    export const LittleEndian: ByteOrder
    export const BigEndian: ByteOrder

    /**
     * Binary encode raw buffer
     */
    export class DataView {
        constructor(buffer: ejs.BufferData)
        /**
         * underlying raw buffer
         */
        readonly buffer: ejs.BufferData
        /**
         * The length in bytes of the buffer.
         */
        readonly byteLength: number
        /**
         * Gets the Uint8 value at the specified byte offset from the start of the view. There is
         * no alignment constraint; multi-byte values may be fetched from any offset.
         * @param byteOffset The place in the buffer at which the value should be retrieved.
         */
        getUint8(byteOffset: number): number
        /**
         * Gets the Uint16 value at the specified byte offset from the start of the view. There is
         * no alignment constraint; multi-byte values may be fetched from any offset.
         * @param byteOffset The place in the buffer at which the value should be retrieved.
         * @param littleEndian If false or undefined, a big-endian value should be read.
         */
        getUint16(byteOffset: number, littleEndian?: boolean): number
        /**
         * Gets the Uint32 value at the specified byte offset from the start of the view. There is
         * no alignment constraint; multi-byte values may be fetched from any offset.
         * @param byteOffset The place in the buffer at which the value should be retrieved.
         * @param littleEndian If false or undefined, a big-endian value should be read.
         */
        getUint32(byteOffset: number, littleEndian?: boolean): number
        /**
         * Gets the Uint64 value at the specified byte offset from the start of the view. There is
         * no alignment constraint; multi-byte values may be fetched from any offset.
         * @param byteOffset The place in the buffer at which the value should be retrieved.
         * @param littleEndian If false or undefined, a big-endian value should be read.
         * @returns If it is within a safe integer that can be represented by js, number is returned. Otherwise, it is returned in the form of a string.
         */
        getUint64(byteOffset: number, littleEndian?: boolean): number | string
        /**
         * Stores an Uint8 value at the specified byte offset from the start of the view.
         * @param byteOffset The place in the buffer at which the value should be set.
         * @param value The value to set. If a string is passed in, strconv.parseUint(value,0,8) is automatically used to convert it to a number.
         */
        setUint8(byteOffset: number, value: number | string): void
        /**
         * Stores an Uint16 value at the specified byte offset from the start of the view.
         * @param byteOffset The place in the buffer at which the value should be set.
         * @param value The value to set. If a string is passed in, strconv.parseUint(value,0,16) is automatically used to convert it to a number.
         * @param littleEndian If false or undefined, a big-endian value should be written.
         */
        setUint16(byteOffset: number, value: number | string, littleEndian?: boolean): void
        /**
         * Stores an Uint32 value at the specified byte offset from the start of the view.
         * @param byteOffset The place in the buffer at which the value should be set.
         * @param value The value to set. If a string is passed in, strconv.parseUint(value,0,32) is automatically used to convert it to a number.
         * @param littleEndian If false or undefined, a big-endian value should be written.
         */
        setUint32(byteOffset: number, value: number | string, littleEndian?: boolean): void
        /**
         * Stores an Uint16 value at the specified byte offset from the start of the view.
         * @param byteOffset The place in the buffer at which the value should be set.
         * @param value The value to set. If a string is passed in, strconv.parseUint(value,0,64) is automatically used to convert it to a number.
         * @param littleEndian If false or undefined, a big-endian value should be written.
         */
        setUint64(byteOffset: number, value: number | string, littleEndian?: boolean): void
        /**
         * Gets the Int8 value at the specified byte offset from the start of the view. There is
         * no alignment constraint; multi-byte values may be fetched from any offset.
         * @param byteOffset The place in the buffer at which the value should be retrieved.
         */
        getInt8(byteOffset: number): number
        /**
         * Gets the Int16 value at the specified byte offset from the start of the view. There is
         * no alignment constraint; multi-byte values may be fetched from any offset.
         * @param byteOffset The place in the buffer at which the value should be retrieved.
         * @param littleEndian If false or undefined, a big-endian value should be read.
         */
        getInt16(byteOffset: number, littleEndian?: boolean): number
        /**
         * Gets the Int32 value at the specified byte offset from the start of the view. There is
         * no alignment constraint; multi-byte values may be fetched from any offset.
         * @param byteOffset The place in the buffer at which the value should be retrieved.
         * @param littleEndian If false or undefined, a big-endian value should be read.
         */
        getInt32(byteOffset: number, littleEndian?: boolean): number
        /**
         * Gets the Int64 value at the specified byte offset from the start of the view. There is
         * no alignment constraint; multi-byte values may be fetched from any offset.
         * @param byteOffset The place in the buffer at which the value should be retrieved.
         * @param littleEndian If false or undefined, a big-endian value should be read.
         * @returns If it is within a safe integer that can be represented by js, number is returned. Otherwise, it is returned in the form of a string.
         */
        getInt64(byteOffset: number, littleEndian?: boolean): number | string
        /**
         * Stores an Int8 value at the specified byte offset from the start of the view.
         * @param byteOffset The place in the buffer at which the value should be set.
         * @param value The value to set. If a string is passed in, strconv.parseInt(value,0,8) is automatically used to convert it to a number.
         */
        setInt8(byteOffset: number, value: number | string): void
        /**
         * Stores an Int16 value at the specified byte offset from the start of the view.
         * @param byteOffset The place in the buffer at which the value should be set.
         * @param value The value to set. If a string is passed in, strconv.parseInt(value,0,16) is automatically used to convert it to a number.
         * @param littleEndian If false or undefined, a big-endian value should be written.
         */
        setInt16(byteOffset: number, value: number | string, littleEndian?: boolean): void
        /**
         * Stores an Int32 value at the specified byte offset from the start of the view.
         * @param byteOffset The place in the buffer at which the value should be set.
         * @param value The value to set. If a string is passed in, strconv.parseInt(value,0,32) is automatically used to convert it to a number.
         * @param littleEndian If false or undefined, a big-endian value should be written.
         */
        setInt32(byteOffset: number, value: number | string, littleEndian?: boolean): void
        /**
         * Stores an Int64 value at the specified byte offset from the start of the view.
         * @param byteOffset The place in the buffer at which the value should be set.
         * @param value The value to set. If a string is passed in, strconv.parseInt(value,0,64) is automatically used to convert it to a number.
         * @param littleEndian If false or undefined, a big-endian value should be written.
         */
        setInt64(byteOffset: number, value: number | string, littleEndian?: boolean): void
    }
}
/**
 * implements base64 encoding as specified by RFC 4648.
 */
declare module "ejs/encoding/base64" {
    /**
   * base64 encoding
   */
    export interface Encoding {
        /**
         * Returns the buffer required to encode n bytes in base64
         */
        encodedLen(n: number | string | ejs.BufferData): number
        /**
         * Returns the length of the buffer required to decode n length base64
         */
        decodedLen(n: number | string | ejs.BufferData): number

        /**
         * Write src to dst after base64 encoding
         * @returns the length of bytes written to dst
         */
        encode(dst: ejs.BufferData, src: string | ejs.BufferData): number
        /**
         * Encoding src to base64 encoding
         * @returns the length of bytes written to dst
         */
        encode(src: string | ejs.BufferData): Uint8Array
        /**
         * Returns src as a base64-encoded string
         */
        encodeToString(src: string | ejs.BufferData): string

        /**
         * Decode src as base64 to dst
         * @returns the length of bytes written to dst. For illegal base64 values, decoding will be performed until the first illegal value encountered.
         * You can use encodedLen(result)==src.length to verify that no invalid encoded values ​​were encountered during decoding
         */
        decode(dst: ejs.BufferData, src: string | ejs.BufferData): number

        /**
         * Decode src as base64
         * @returns the length of bytes written to dst. For illegal base64 values, decoding will be performed until the first illegal value encountered.
         * You can use encodedLen(result.length)==src.length to verify that no invalid encoded values ​​were encountered during decoding
         */
        decode(src: string | ejs.BufferData): Uint8Array
    }
    /**
     * Returns the buffer required to encode n bytes in base64
     */
    export function encodedLen(n: number | string | ejs.BufferData, padding?: boolean): number
    /**
     * Returns the length of the buffer required to decode n length base64
     */
    export function decodedLen(n: number | string | ejs.BufferData, padding?: boolean): number
    export const encodeStd = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    export const encodeURL = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
    /**
     * Implemented base64 algorithm
     */
    export class Base64 implements Encoding {
        static get std(): Base64
        static get rawstd(): Base64
        static get url(): Base64
        static get rawurl(): Base64

        constructor(encoder: string | Base64, padding?: number | string | ejs.BufferData)
        /**
         * Returns the buffer required to encode n bytes in base64
         */
        encodedLen(n: number | string | ejs.BufferData): number
        /**
         * Returns the length of the buffer required to decode n length base64
         */
        decodedLen(n: number | string | ejs.BufferData): number
        /**
         * Write src to dst after base64 encoding
         * @returns the length of bytes written to dst
         */
        encode(dst: ejs.BufferData, src: string | ejs.BufferData): number
        /**
         * Encoding src to base64 encoding
         * @returns the length of bytes written to dst
         */
        encode(src: string | ejs.BufferData): Uint8Array
        /**
         * Returns src as a base64-encoded string
         */
        encodeToString(src: string | ejs.BufferData): string
        /**
         * Decode src as base64 to dst
         * @returns the length of bytes written to dst. For illegal base64 values, decoding will be performed until the first illegal value encountered.
         * You can use encodedLen(result)==src.length to verify that no invalid encoded values ​​were encountered during decoding
         */
        decode(dst: ejs.BufferData, src: string | ejs.BufferData): number

        /**
         * Decode src as base64
         * @returns the length of bytes written to dst. For illegal base64 values, decoding will be performed until the first illegal value encountered.
         * You can use encodedLen(result.length)==src.length to verify that no invalid encoded values ​​were encountered during decoding
         */
        decode(src: string | ejs.BufferData): Uint8Array
    }
}
/**
 * most of which are ported from golang
 */
declare module "ejs/encoding/hex" {
    /**
     * Returns the encoded length of n bytes
     */
    export function encodedLen(n: number): number
    /**
     * Returns the length in bytes of the encoded string
     */
    export function encodedLen(s: string): number
    /**
     * encodedLen(data.byteLength)
     */
    export function encodedLen(data: ejs.BufferData): number
    export function encodedLen(v: number | string | ejs.BufferData): number

    /**
     * Returns the buffer length required to decode n bytes hex
     */
    export function decodedLen(n: number): number
    /**
     * Returns the buffer length required to decode the hex string
     */
    export function decodedLen(decoded: string): number
    /**
     * decodedLen(data.byteLength)
     */
    export function decodedLen(decoded: ejs.BufferData): number
    export function decodedLen(v: number | string | ejs.BufferData): number

    /**
     * Encodes src into dst. It returns the numberof bytes written to dst, 
     */
    export function encode(dst: ejs.BufferData, src: string | ejs.BufferData, uppercase = false): number
    /**
     * Returns the hexadecimal encoding of src.
     */
    export function encodeToString(src: string | ejs.BufferData, uppercase = false): string
    /**
     * Decodes src into dst,
     * returning the actual number of bytes written to dst.
     * 
     * Decode expects that src contains only hexadecimal
     * characters and that src has even length.
     * If the input is malformed, Decode returns the number
     * of bytes decoded before the error.
     * 
     * You can tell if an error occurred by min(decodedLen(x),dst.length) == returns.
     */
    export function decode(dst: ejs.BufferData, src: string | ejs.BufferData): number

    /**
     * Returns src decoded in hex backend content
     * 
     * Decode expects that src contains only hexadecimal
     * characters and that src has even length.
     * If the input is malformed, Decode returns the number
     * of bytes decoded before the error.
     * 
     * You can tell if an error occurred by decodedLen(x) == returns.length
     */
    export function decode(src: string | ejs.BufferData): Uint8Array

    /**
     * 
     * Report whether v is an hexadecimal character
     */
    export function isHex(v: number): boolean
    /**
     * Reports whether v is an hex-encoded content
     */
    export function isHex(v: string | ejs.BufferData): boolean
}
/**
 * Implemented common hash algorithms
 */
declare module "ejs/hash" {
    export class Hash {
        protected constructor()
        /**
         * Create a copy of the current state hash
         * @returns A copy of the current state hash
         */
        clone(): Hash
        /**
         * Bytes of digest
         */
        readonly hashsize: number
        /**
         * The hash's underlying block size.
         * The Write method must be able to accept any amount
         * of data, but it may operate more efficiently if all writes
         * are a multiple of the block size
         */
        readonly blocksize: number
        /**
         *  Resets the hash to its initial state.
         * @returns self
         */
        reset(): Hash
        /**
         * Append data to hash
         * @returns self
         */
        write(data?: string | ejs.BufferData): Hash
        /**
         * Append data to hash and returns the resulting.
         * It does not change the underlying hash state.
         */
        sum(data?: string | ejs.BufferData): Uint8Array

        /**
         * Similar to sum but writes the hash value to dst
         * @returns hashsize
         */
        sumTo(dst: ejs.BufferData, data?: string | ejs.BufferData): number

        /**
         * Append data to hash and returns the resulting.
         * Once this function is called, you must call reset to correctly recalculate the hash.
         */
        done(data?: string | ejs.BufferData): Uint8Array
        /**
         * Similar to done but writes the hash value to dst
         * @returns hashsize
         */
        doneTo(dst: ejs.BufferData, data?: string | ejs.BufferData): number
    }
    export class MD5 extends Hash {
        constructor()
        /**
         * The size of an MD5 checksum in bytes.
         */
        static get hashsize(): number
        /**
         * The blocksize of MD5 in bytes.
         */
        static get blocksize(): number
        /**
         * return MD5 checksum of the data
         */
        static sum(data?: string | ejs.BufferData): Uint8Array
        /**
         * Write MD5 checksum of the data to dst
         * @returns hashsize
         */
        static sumTo(dst: ejs.BufferData, data?: string | ejs.BufferData): number

        /**
         * Calculate hmac value and return result
         */
        static hmac(key?: string | ejs.BufferData, data?: string | ejs.BufferData): Uint8Array
        /**
         * Similar to hmac function but writes the result to dst
         * @returns hashsize
         */
        static hmacTo(dst: ejs.BufferData, key?: string | ejs.BufferData, data?: string | ejs.BufferData): number
        /**
         * Create an HMAC instance
         */
        static createHMAC(key?: string | ejs.BufferData): Hash
    }
    export class SHA1 extends Hash {
        constructor()
        /**
         * The size of an SHA1 checksum in bytes.
         */
        static get hashsize(): number
        /**
         * The blocksize of SHA1 in bytes.
         */
        static get blocksize(): number
        /**
         * return SHA1 checksum of the data
         */
        static sum(data?: string | ejs.BufferData): Uint8Array
        /**
         * Write SHA1 checksum of the data to dst
         * @returns hashsize
         */
        static sumTo(dst: ejs.BufferData, data?: string | ejs.BufferData): number

        /**
         * Calculate hmac value and return result
         */
        static hmac(key?: string | ejs.BufferData, data?: string | ejs.BufferData): Uint8Array
        /**
         * Similar to hmac function but writes the result to dst
         * @returns hashsize
         */
        static hmacTo(dst: ejs.BufferData, key?: string | ejs.BufferData, data?: string | ejs.BufferData): number
        /**
         * Create an HMAC instance
         */
        static createHMAC(key?: string | ejs.BufferData): Hash
    }

    export class SHA256_224 extends Hash {
        constructor()
        /**
         * The size of an SHA256_224 checksum in bytes.
         */
        static get hashsize(): number
        /**
         * The blocksize of SHA256_224 in bytes.
         */
        static get blocksize(): number
        /**
         * return SHA256_224 checksum of the data
         */
        static sum(data?: string | ejs.BufferData): Uint8Array
        /**
         * Write SHA256_224 checksum of the data to dst
         * @returns hashsize
         */
        static sumTo(dst: ejs.BufferData, data?: string | ejs.BufferData): number
        /**
         * Calculate hmac value and return result
         */
        static hmac(key?: string | ejs.BufferData, data?: string | ejs.BufferData): Uint8Array
        /**
         * Similar to hmac function but writes the result to dst
         * @returns hashsize
         */
        static hmacTo(dst: ejs.BufferData, key?: string | ejs.BufferData, data?: string | ejs.BufferData): number
        /**
         * Create an HMAC instance
         */
        static createHMAC(key?: string | ejs.BufferData): Hash
    }
    export class SHA256 extends Hash {
        constructor()
        /**
         * The size of an SHA256 checksum in bytes.
         */
        static get hashsize(): number
        /**
         * The blocksize of SHA256 in bytes.
         */
        static get blocksize(): number
        /**
         * return SHA256 checksum of the data
         */
        static sum(data?: string | ejs.BufferData): Uint8Array
        /**
         * Write SHA256 checksum of the data to dst
         * @returns hashsize
         */
        static sumTo(dst: ejs.BufferData, data?: string | ejs.BufferData): number
        /**
         * Calculate hmac value and return result
         */
        static hmac(key?: string | ejs.BufferData, data?: string | ejs.BufferData): Uint8Array
        /**
         * Similar to hmac function but writes the result to dst
         * @returns hashsize
         */
        static hmacTo(dst: ejs.BufferData, key?: string | ejs.BufferData, data?: string | ejs.BufferData): number
        /**
         * Create an HMAC instance
         */
        static createHMAC(key?: string | ejs.BufferData): Hash
    }
    export class SHA512_224 extends Hash {
        constructor()
        /**
         * The size of an SHA512_224 checksum in bytes.
         */
        static get hashsize(): number
        /**
         * The blocksize of SHA512_224 in bytes.
         */
        static get blocksize(): number
        /**
         * return SHA512_224 checksum of the data
         */
        static sum(data?: string | ejs.BufferData): Uint8Array
        /**
         * Write SHA512_224 checksum of the data to dst
         * @returns hashsize
         */
        static sumTo(dst: ejs.BufferData, data?: string | ejs.BufferData): number
        /**
         * Calculate hmac value and return result
         */
        static hmac(key?: string | ejs.BufferData, data?: string | ejs.BufferData): Uint8Array
        /**
         * Similar to hmac function but writes the result to dst
         * @returns hashsize
         */
        static hmacTo(dst: ejs.BufferData, key?: string | ejs.BufferData, data?: string | ejs.BufferData): number
        /**
         * Create an HMAC instance
         */
        static createHMAC(key?: string | ejs.BufferData): Hash
    }
    export class SHA512_256 extends Hash {
        constructor()
        /**
         * The size of an SHA512_256 checksum in bytes.
         */
        static get hashsize(): number
        /**
         * The blocksize of SHA512_256 in bytes.
         */
        static get blocksize(): number
        /**
         * return SHA512_256 checksum of the data
         */
        static sum(data?: string | ejs.BufferData): Uint8Array
        /**
         * Write SHA512_256 checksum of the data to dst
         * @returns hashsize
         */
        static sumTo(dst: ejs.BufferData, data?: string | ejs.BufferData): number
        /**
         * Calculate hmac value and return result
         */
        static hmac(key?: string | ejs.BufferData, data?: string | ejs.BufferData): Uint8Array
        /**
         * Similar to hmac function but writes the result to dst
         * @returns hashsize
         */
        static hmacTo(dst: ejs.BufferData, key?: string | ejs.BufferData, data?: string | ejs.BufferData): number
        /**
         * Create an HMAC instance
         */
        static createHMAC(key?: string | ejs.BufferData): Hash
    }
    export class SHA512_384 extends Hash {
        constructor()
        /**
         * The size of an SHA512_384 checksum in bytes.
         */
        static get hashsize(): number
        /**
         * The blocksize of SHA512_384 in bytes.
         */
        static get blocksize(): number
        /**
         * return SHA512_384 checksum of the data
         */
        static sum(data?: string | ejs.BufferData): Uint8Array
        /**
         * Write SHA512_384 checksum of the data to dst
         * @returns hashsize
         */
        static sumTo(dst: ejs.BufferData, data?: string | ejs.BufferData): number
        /**
         * Calculate hmac value and return result
         */
        static hmac(key?: string | ejs.BufferData, data?: string | ejs.BufferData): Uint8Array
        /**
         * Similar to hmac function but writes the result to dst
         * @returns hashsize
         */
        static hmacTo(dst: ejs.BufferData, key?: string | ejs.BufferData, data?: string | ejs.BufferData): number
        /**
         * Create an HMAC instance
         */
        static createHMAC(key?: string | ejs.BufferData): Hash
    }
    export class SHA512 extends Hash {
        constructor()
        /**
         * The size of an SHA512 checksum in bytes.
         */
        static get hashsize(): number
        /**
         * The blocksize of SHA512 in bytes.
         */
        static get blocksize(): number
        /**
         * return SHA512 checksum of the data
         */
        static sum(data?: string | ejs.BufferData): Uint8Array
        /**
         * Write SHA512 checksum of the data to dst
         * @returns hashsize
         */
        static sumTo(dst: ejs.BufferData, data?: string | ejs.BufferData): number
        /**
         * Calculate hmac value and return result
         */
        static hmac(key?: string | ejs.BufferData, data?: string | ejs.BufferData): Uint8Array
        /**
         * Similar to hmac function but writes the result to dst
         * @returns hashsize
         */
        static hmacTo(dst: ejs.BufferData, key?: string | ejs.BufferData, data?: string | ejs.BufferData): number
        /**
         * Create an HMAC instance
         */
        static createHMAC(key?: string | ejs.BufferData): Hash
    }
    export class SHA3_224 extends Hash {
        constructor()
        /**
         * The size of an SHA3_224 checksum in bytes.
         */
        static get hashsize(): number
        /**
         * The blocksize of SHA3_224 in bytes.
         */
        static get blocksize(): number
        /**
         * return SHA3_224 checksum of the data
         */
        static sum(data?: string | ejs.BufferData): Uint8Array
        /**
         * Write SHA3_224 checksum of the data to dst
         * @returns hashsize
         */
        static sumTo(dst: ejs.BufferData, data?: string | ejs.BufferData): number
        /**
         * Calculate hmac value and return result
         */
        static hmac(key?: string | ejs.BufferData, data?: string | ejs.BufferData): Uint8Array
        /**
         * Similar to hmac function but writes the result to dst
         * @returns hashsize
         */
        static hmacTo(dst: ejs.BufferData, key?: string | ejs.BufferData, data?: string | ejs.BufferData): number
        /**
         * Create an HMAC instance
         */
        static createHMAC(key?: string | ejs.BufferData): Hash
    }
    export class SHA3_256 extends Hash {
        constructor()
        /**
         * The size of an SHA3_256 checksum in bytes.
         */
        static get hashsize(): number
        /**
         * The blocksize of SHA3_256 in bytes.
         */
        static get blocksize(): number
        /**
         * return SHA3_256 checksum of the data
         */
        static sum(data?: string | ejs.BufferData): Uint8Array
        /**
         * Write SHA3_256 checksum of the data to dst
         * @returns hashsize
         */
        static sumTo(dst: ejs.BufferData, data?: string | ejs.BufferData): number
        /**
         * Calculate hmac value and return result
         */
        static hmac(key?: string | ejs.BufferData, data?: string | ejs.BufferData): Uint8Array
        /**
         * Similar to hmac function but writes the result to dst
         * @returns hashsize
         */
        static hmacTo(dst: ejs.BufferData, key?: string | ejs.BufferData, data?: string | ejs.BufferData): number
        /**
         * Create an HMAC instance
         */
        static createHMAC(key?: string | ejs.BufferData): Hash
    }
    export class SHA3_384 extends Hash {
        constructor()
        /**
         * The size of an SHA3_384 checksum in bytes.
         */
        static get hashsize(): number
        /**
         * The blocksize of SHA3_384 in bytes.
         */
        static get blocksize(): number
        /**
         * return SHA3_384 checksum of the data
         */
        static sum(data?: string | ejs.BufferData): Uint8Array
        /**
         * Write SHA3_384 checksum of the data to dst
         * @returns hashsize
         */
        static sumTo(dst: ejs.BufferData, data?: string | ejs.BufferData): number
        /**
         * Calculate hmac value and return result
         */
        static hmac(key?: string | ejs.BufferData, data?: string | ejs.BufferData): Uint8Array
        /**
         * Similar to hmac function but writes the result to dst
         * @returns hashsize
         */
        static hmacTo(dst: ejs.BufferData, key?: string | ejs.BufferData, data?: string | ejs.BufferData): number
        /**
         * Create an HMAC instance
         */
        static createHMAC(key?: string | ejs.BufferData): Hash
    }
    export class SHA3_512 extends Hash {
        constructor()
        /**
         * The size of an SHA3_512 checksum in bytes.
         */
        static get hashsize(): number
        /**
         * The blocksize of SHA3_512 in bytes.
         */
        static get blocksize(): number
        /**
         * return SHA3_512 checksum of the data
         */
        static sum(data?: string | ejs.BufferData): Uint8Array
        /**
         * Write SHA3_512 checksum of the data to dst
         * @returns hashsize
         */
        static sumTo(dst: ejs.BufferData, data?: string | ejs.BufferData): number
        /**
         * Calculate hmac value and return result
         */
        static hmac(key?: string | ejs.BufferData, data?: string | ejs.BufferData): Uint8Array
        /**
         * Similar to hmac function but writes the result to dst
         * @returns hashsize
         */
        static hmacTo(dst: ejs.BufferData, key?: string | ejs.BufferData, data?: string | ejs.BufferData): number
        /**
         * Create an HMAC instance
         */
        static createHMAC(key?: string | ejs.BufferData): Hash
    }
    export class Hash32 extends Hash {
        protected constructor()
        /**
         * Similar to the sum function but the return value is uint32 checksum
         */
        sum32(data?: string | ejs.BufferData): number
        /**
         * Similar to the done function but the return value is uint32 checksum
         */
        done32(data?: string | ejs.BufferData): number
    }

    export class Adler32 extends Hash32 {
        constructor()
        /**
         * The size of an Adler32 checksum in bytes.
         */
        static readonly hashsize = 4
        /**
         * The blocksize of Adler32 in bytes.
         */
        static readonly blocksize = 4
        /**
         * return Adler32 checksum of the data
         */
        static sum32(data?: string | ejs.BufferData): number
        /**
         * return Adler32 checksum of the data
         */
        static sum(data?: string | ejs.BufferData): Uint8Array
        /**
         * Write Adler32 checksum of the data to dst
         * @returns hashsize
         */
        static sumTo(dst: ejs.BufferData, data?: string | ejs.BufferData): number
    }
    /**
     * CRC-32 using the IEEE polynomial.
     */
    export class CRC32 extends Hash32 {
        constructor()
        /**
         * The size of an CRC32 checksum in bytes.
         */
        static readonly hashsize = 4
        /**
         * The blocksize of CRC32 in bytes.
         */
        static readonly blocksize = 1
        /**
         * return CRC32 checksum of the data
         */
        static sum32(data?: string | Uint8Array): number
        /**
         * return CRC32 checksum of the data
         */
        static sum(data?: string | Uint8Array): Uint8Array
        /**
         * Write CRC32 checksum of the data to dst
         * @returns hashsize
         */
        static sumTo(dst: Uint8Array, data?: string | Uint8Array): number
    }
}
/**
 * Some encryption algorithms
 */
declare module "ejs/crypto" {
    export enum CTRMode {
        LITTLE_ENDIAN = deps.LITTLE_ENDIAN,
        BIG_ENDIAN = deps.BIG_ENDIAN,
        LITTLE_ENDIAN_RFC3686 = deps.LITTLE_ENDIAN_RFC3686,
        BIG_ENDIAN_RFC3686 = deps.BIG_ENDIAN_RFC3686,
    }
    /**
     * Implemented AES encryption and decryption algorithm
     * 
     * @remarks
     * Either key length 16, 24, or 32 bytes to select AES-128, AES-192, or AES-256
     */
    export class AES {
        private constructor()
        /**
         * returns the cipher's block size.
         */
        readonly blocksize = 16
        /**
         * Encrypt plaintext using ECB mode
        * @param key AES key
         * @param plaintext data to be encrypted
         * @returns encrypted data
         */
        static encryptECB(key: string | Uint8Array, plaintext: string | Uint8Array): Uint8Array
        /**
         * Encrypt plaintext using ECB mode
        * @param key AES key
         * @param ciphertext encrypted data
         * @param plaintext data to be encrypted
         * @returns The length in bytes of the output ciphertext
         */
        static encryptECBTo(key: string | Uint8Array, ciphertext: Uint8Array, plaintext: string | Uint8Array): number
        /**
         * Decrypt ciphertext using ECB mode
        * @param key AES key
         * @param ciphertext data to be decrypted
         * @returns decrypted data
         */
        static decryptECB(key: string | Uint8Array, ciphertext: Uint8Array): Uint8Array
        /**
         * Decrypt ciphertext using ECB mode
        * @param key AES key
         * @param plaintext decrypted data
         * @param ciphertext data to be decrypted
         * @returns The length in bytes of the output plaintext
         */
        static decryptECBTo(key: string | Uint8Array, plaintext: Uint8Array, ciphertext: Uint8Array): number
        /**
         * 
        * @param key AES key
         * @returns ECB
         */
        static ecb(key: string | Uint8Array): ECB

        /**
         * Encrypt plaintext using CBC mode
        * @param key AES key
         * @param iv initialization vector
         * @param plaintext data to be encrypted
         * @returns encrypted data
         */
        static encryptCBC(key: string | Uint8Array, iv: string | Uint8Array, plaintext: string | Uint8Array): Uint8Array
        /**
         * Encrypt plaintext using CBC mode
        * @param key AES key
         * @param iv initialization vector
         * @param ciphertext encrypted data
         * @param plaintext data to be encrypted
         * @returns The length in bytes of the output ciphertext
         */
        static encryptCBCTo(key: string | Uint8Array, iv: string | Uint8Array, ciphertext: Uint8Array, plaintext: string | Uint8Array): number
        /**
         * Decrypt ciphertext using CBC mode
        * @param key AES key
         * @param iv initialization vector
         * @param ciphertext data to be decrypted
         * @returns decrypted data
         */
        static decryptCBC(key: string | Uint8Array, iv: string | Uint8Array, ciphertext: Uint8Array): Uint8Array
        /**
         * Decrypt ciphertext using CBC mode
        * @param key AES key
         * @param iv initialization vector
         * @param plaintext decrypted data
         * @param ciphertext data to be decrypted
         * @returns The length in bytes of the output plaintext
         */
        static decryptCBCTo(key: string | Uint8Array, iv: string | Uint8Array, plaintext: Uint8Array, ciphertext: Uint8Array): number
        /**
         * 
        * @param key AES key
         * @param iv initialization vector
         * @returns CBC
         */
        static cbc(key: string | Uint8Array, iv: string | Uint8Array): CBC

        /**
         * Encrypt plaintext using CFB mode
        * @param key AES key
         * @param iv initialization vector
         * @param plaintext data to be encrypted
         * @returns encrypted data
         */
        static encryptCFB(key: string | Uint8Array, iv: string | Uint8Array, plaintext: string | Uint8Array): Uint8Array
        /**
         * Encrypt plaintext using CFB mode
        * @param key AES key
         * @param iv initialization vector
         * @param ciphertext encrypted data
         * @param plaintext data to be encrypted
         * @returns The length in bytes of the output ciphertext
         */
        static encryptCFBTo(key: string | Uint8Array, iv: string | Uint8Array, ciphertext: Uint8Array, plaintext: string | Uint8Array): number
        /**
         * Decrypt ciphertext using CFB mode
        * @param key AES key
         * @param iv initialization vector
         * @param ciphertext data to be decrypted
         * @returns decrypted data
         */
        static decryptCFB(key: string | Uint8Array, iv: string | Uint8Array, ciphertext: Uint8Array): Uint8Array
        /**
         * Decrypt ciphertext using CFB mode
        * @param key AES key
         * @param iv initialization vector
         * @param plaintext decrypted data
         * @param ciphertext data to be decrypted
         * @returns The length in bytes of the output plaintext
         */
        static decryptCFBTo(key: string | Uint8Array, iv: string | Uint8Array, plaintext: Uint8Array, ciphertext: Uint8Array): number
        /**
         * 
        * @param key AES key
         * @param iv initialization vector
         * @returns CFB
         */
        static cfb(key: string | Uint8Array, iv: string | Uint8Array): CFB


        /**
         * Encrypt plaintext using OFB mode
        * @param key AES key
         * @param iv initialization vector
         * @param plaintext data to be encrypted
         * @returns encrypted data
         */
        static encryptOFB(key: string | Uint8Array, iv: string | Uint8Array, plaintext: string | Uint8Array): Uint8Array
        /**
         * Encrypt plaintext using OFB mode
        * @param key AES key
         * @param iv initialization vector
         * @param ciphertext encrypted data
         * @param plaintext data to be encrypted
         * @returns The length in bytes of the output ciphertext
         */
        static encryptOFBTo(key: string | Uint8Array, iv: string | Uint8Array, ciphertext: Uint8Array, plaintext: string | Uint8Array): number
        /**
         * Decrypt ciphertext using OFB mode
        * @param key AES key
         * @param iv initialization vector
         * @param ciphertext data to be decrypted
         * @returns decrypted data
         */
        static decryptOFB(key: string | Uint8Array, iv: string | Uint8Array, ciphertext: Uint8Array): Uint8Array
        /**
         * Decrypt ciphertext using OFB mode
        * @param key AES key
         * @param iv initialization vector
         * @param plaintext decrypted data
         * @param ciphertext data to be decrypted
         * @returns The length in bytes of the output plaintext
         */
        static decryptOFBTo(key: string | Uint8Array, iv: string | Uint8Array, plaintext: Uint8Array, ciphertext: Uint8Array): number
        /**
         * 
        * @param key AES key
         * @param iv initialization vector
         * @returns OFB
         */
        static ofb(key: string | Uint8Array, iv: string | Uint8Array): OFB

        /**
         * Encrypt plaintext using CTR mode
        * @param key AES key
         * @param iv initialization vector
         * @param mode CTR Mode
         * @param plaintext data to be encrypted
         * @returns encrypted data
         */
        static encryptCTR(key: string | Uint8Array, iv: string | Uint8Array, mode: CTRMode, plaintext: string | Uint8Array): Uint8Array
        /**
         * Encrypt plaintext using CTR mode
        * @param key AES key
         * @param iv initialization vector
         * @param mode CTR Mode
         * @param ciphertext encrypted data
         * @param plaintext data to be encrypted
         * @returns The length in bytes of the output ciphertext
         */
        static encryptCTRTo(key: string | Uint8Array, iv: string | Uint8Array, mode: CTRMode, ciphertext: Uint8Array, plaintext: string | Uint8Array): number
        /**
         * Decrypt ciphertext using CTR mode
        * @param key AES key
         * @param iv initialization vector
         * @param mode CTR Mode
         * @param ciphertext data to be decrypted
         * @returns decrypted data
         */
        static decryptCTR(key: string | Uint8Array, iv: string | Uint8Array, mode: CTRMode, ciphertext: Uint8Array): Uint8Array
        /**
         * Decrypt ciphertext using CTR mode
        * @param key AES key
         * @param iv initialization vector
         * @param mode CTR Mode
         * @param plaintext decrypted data
         * @param ciphertext data to be decrypted
         * @returns The length in bytes of the output plaintext
         */
        static decryptCTRTo(key: string | Uint8Array, iv: string | Uint8Array, mode: CTRMode, plaintext: Uint8Array, ciphertext: Uint8Array): number
        /**
         * 
        * @param key AES key
         * @param iv initialization vector
         * @returns OFB
         */
        static ctr(key: string | Uint8Array, iv: string | Uint8Array, mode: number): CTR

        /**
        * Encrypt plaintext using GCM mode
        * @remarks
        * The ciphertext will have a 16-byte signature at the end compared to the plaintext
        * @param key AES key
        * @param iv Only the first 12 bytes are valid. GCM IV must be exactly 12 bytes long according to NIST SP 800-38D
        * @param adata Optional additional authentication data
        * @param plaintext data to be encrypted
        * @returns encrypted data
        */
        static encryptGCM(key: string | Uint8Array, iv: string | Uint8Array, adata: string | Uint8Array | null | undefined, plaintext: string | Uint8Array): Uint8Array
        /**
        * Encrypt plaintext using GCM mode
        * @remarks
        * The ciphertext will have a 16-byte signature at the end compared to the plaintext
        * @param key AES key
        * @param iv Only the first 12 bytes are valid. GCM IV must be exactly 12 bytes long according to NIST SP 800-38D
        * @param adata Optional additional authentication data
         * @param ciphertext encrypted data
         * @param plaintext data to be encrypted
         * @param tag If set, the signature will be output to the tag instead of being added to the end of the ciphertext
         * @returns The length in bytes of the output ciphertext
         */
        static encryptGCMTo(key: string | Uint8Array, iv: string | Uint8Array, adata: string | Uint8Array | null | undefined, ciphertext: Uint8Array, plaintext: string | Uint8Array, tag?: Uint8Array): number
        /**
        * Decrypt ciphertext using GCM mode
        * @remarks
        * The ciphertext will have a 16-byte signature at the end compared to the plaintext
        * @param key AES key
        * @param iv Only the first 12 bytes are valid. GCM IV must be exactly 12 bytes long according to NIST SP 800-38D
        * @param adata Optional additional authentication data
         * @param ciphertext data to be decrypted
         * @param tag If set, the signature will be from the tag instead of from end of the ciphertext
         * @returns decrypted data
         */
        static decryptGCM(key: string | Uint8Array, iv: string | Uint8Array, adata: string | Uint8Array | null | undefined, ciphertext: Uint8Array, tag?: Uint8Array | null): Uint8Array
        /**
        * Decrypt ciphertext using GCM mode
        * @remarks
        * The ciphertext will have a 16-byte signature at the end compared to the plaintext
        * @param key AES key
        * @param iv Only the first 12 bytes are valid. GCM IV must be exactly 12 bytes long according to NIST SP 800-38D
        * @param adata Optional additional authentication data
         * @param plaintext decrypted data
         * @param ciphertext data to be decrypted
         * @param tag If set, the signature will be from the tag instead of from end of the ciphertext
         * @returns The length in bytes of the output plaintext
         */
        static decryptGCMTo(key: string | Uint8Array, iv: string | Uint8Array, adata: string | Uint8Array | null | undefined, plaintext: Uint8Array, ciphertext: Uint8Array, tag?: Uint8Array | null): number
    }
    /**
     * The most basic ECB encryption mode.
     * @remarks
     * In ECB mode, the plaintext and ciphertext must be integer multiples of blocksize.
     */
    export class ECB {
        private constructor()
        /**
         * returns the cipher's block size.
         */
        readonly blocksize: number
        /**
         * Encrypt plaintext using ECB mode
         * @param plaintext data to be encrypted
         * @returns encrypted data
         */
        encrypt(plaintext: string | Uint8Array): Uint8Array
        /**
         * Encrypt plaintext using ECB mode
         * @param ciphertext encrypted data
         * @param plaintext data to be encrypted
         * @returns The length in bytes of the output ciphertext
         */
        encryptTo(ciphertext: Uint8Array, plaintext: string | Uint8Array): number
        /**
         * Decrypt ciphertext using ECB mode
         * @param ciphertext data to be decrypted
         * @returns decrypted data
         */
        decrypt(ciphertext: Uint8Array): Uint8Array
        /**
         * Decrypt ciphertext using ECB mode
         * @param plaintext decrypted data
         * @param ciphertext data to be decrypted
         * @returns The length in bytes of the output plaintext
         */
        decryptTo(plaintext: Uint8Array, ciphertext: Uint8Array): number
    }

    /**
     * The CBC encryption mode.
     * @remarks
     * In CBC mode, the plaintext and ciphertext must be integer multiples of blocksize.
     * 
     * The same instance can only be used as an encryptor or a decryptor. Do not mix them up, otherwise you will not get the correct result.
     */
    export class CBC {
        private constructor()
        /**
         * returns the cipher's block size.
         */
        readonly blocksize: number
        /**
         * Encrypt plaintext using CBC mode
         * @param plaintext data to be encrypted
         * @returns encrypted data
         */
        encrypt(plaintext: string | Uint8Array): Uint8Array
        /**
         * Encrypt plaintext using CBC mode
         * @param ciphertext encrypted data
         * @param plaintext data to be encrypted
         * @returns The length in bytes of the output ciphertext
         */
        encryptTo(ciphertext: Uint8Array, plaintext: string | Uint8Array): number
        /**
         * Decrypt ciphertext using CBC mode
         * @param ciphertext data to be decrypted
         * @returns decrypted data
         */
        decrypt(ciphertext: Uint8Array): Uint8Array
        /**
         * Decrypt ciphertext using CBC mode
         * @param plaintext decrypted data
         * @param ciphertext data to be decrypted
         * @returns The length in bytes of the output plaintext
         */
        decryptTo(plaintext: Uint8Array, ciphertext: Uint8Array): number
    }

    /**
     * The CFB encryption mode.
     * @remarks
     * CFB mode does not require padding or alignment and is data flow friendly.
     * 
     * The same instance can only be used as an encryptor or a decryptor. Do not mix them up, otherwise you will not get the correct result.
     */
    export class CFB {
        private constructor()
        /**
         * Encrypt plaintext using CFB mode
         * @param plaintext data to be encrypted
         * @returns encrypted data
         */
        encrypt(plaintext: string | Uint8Array): Uint8Array
        /**
         * Encrypt plaintext using CFB mode
         * @param ciphertext encrypted data
         * @param plaintext data to be encrypted
         * @returns The length in bytes of the output ciphertext
         */
        encryptTo(ciphertext: Uint8Array, plaintext: string | Uint8Array): number
        /**
         * Decrypt ciphertext using CFB mode
         * @param ciphertext data to be decrypted
         * @returns decrypted data
         */
        decrypt(ciphertext: Uint8Array): Uint8Array
        /**
         * Decrypt ciphertext using CFB mode
         * @param plaintext decrypted data
         * @param ciphertext data to be decrypted
         * @returns The length in bytes of the output plaintext
         */
        decryptTo(plaintext: Uint8Array, ciphertext: Uint8Array): number
    }

    /**
     * The CFB encryption mode.
     * @remarks
     * CFB mode does not require padding or alignment and is data flow friendly.
     * 
     * The same instance can only be used as an encryptor or a decryptor. Do not mix them up, otherwise you will not get the correct result.
     */
    export class OFB {
        private constructor()
        /**
         * Encrypt plaintext using OFB mode
         * @param plaintext data to be encrypted
         * @returns encrypted data
         */
        encrypt(plaintext: string | Uint8Array): Uint8Array
        /**
         * Encrypt plaintext using OFB mode
         * @param ciphertext encrypted data
         * @param plaintext data to be encrypted
         * @returns The length in bytes of the output ciphertext
         */
        encryptTo(ciphertext: Uint8Array, plaintext: string | Uint8Array): number
        /**
         * Decrypt ciphertext using OFB mode
         * @param ciphertext data to be decrypted
         * @returns decrypted data
         */
        decrypt(ciphertext: Uint8Array): Uint8Array
        /**
         * Decrypt ciphertext using OFB mode
         * @param plaintext decrypted data
         * @param ciphertext data to be decrypted
         * @returns The length in bytes of the output plaintext
         */
        decryptTo(plaintext: Uint8Array, ciphertext: Uint8Array): number
    }

    /**
     * The CTR encryption mode.
     * @remarks
     * CTR mode does not require padding or alignment and is data flow friendly.
     * 
     * The same instance can only be used as an encryptor or a decryptor. Do not mix them up, otherwise you will not get the correct result.
     */
    export class CTR {
        private constructor()
        /**
         * Encrypt plaintext using CTR mode
         * @param plaintext data to be encrypted
         * @returns encrypted data
         */
        encrypt(plaintext: string | Uint8Array): Uint8Array
        /**
         * Encrypt plaintext using CTR mode
         * @param ciphertext encrypted data
         * @param plaintext data to be encrypted
         * @returns The length in bytes of the output ciphertext
         */
        encryptTo(ciphertext: Uint8Array, plaintext: string | Uint8Array): number
        /**
         * Decrypt ciphertext using CTR mode
         * @param ciphertext data to be decrypted
         * @returns decrypted data
         */
        decrypt(ciphertext: Uint8Array): Uint8Array
        /**
         * Decrypt ciphertext using CTR mode
         * @param plaintext decrypted data
         * @param ciphertext data to be decrypted
         * @returns The length in bytes of the output plaintext
         */
        decryptTo(plaintext: Uint8Array, ciphertext: Uint8Array): number
    }
    /**
     * The GCM encryption mode.
     * @remarks
     * CTR mode does not require padding or alignment and is data flow friendly.
     * 
     */
    export class GCM {
        private constructor()
        /**
        * Encrypt plaintext using GCM mode
        * @remarks
        * The ciphertext will have a 16-byte signature at the end compared to the plaintext
        * @param plaintext data to be encrypted
        * @returns encrypted data
        */
        encrypt(plaintext: string | Uint8Array): Uint8Array
        /**
        * Encrypt plaintext using GCM mode
        * @remarks
        * The ciphertext will have a 16-byte signature at the end compared to the plaintext
         * @param ciphertext encrypted data
         * @param plaintext data to be encrypted
         * @param tag If set, the signature will be output to the tag instead of being added to the end of the ciphertext
         * @returns The length in bytes of the output ciphertext
         */
        encryptTo(ciphertext: Uint8Array, plaintext: string | Uint8Array, tag?: Uint8Array): number
        /**
        * Decrypt ciphertext using GCM mode
        * @remarks
        * The ciphertext will have a 16-byte signature at the end compared to the plaintext
         * @param ciphertext data to be decrypted
         * @param tag If set, the signature will be from the tag instead of from end of the ciphertext
         * @returns decrypted data
         */
        decrypt(ciphertext: Uint8Array, tag?: Uint8Array | null): Uint8Array
        /**
         * Decrypt ciphertext using CTR mode
         * @param plaintext decrypted data
         * @param ciphertext data to be decrypted
         * @returns The length in bytes of the output plaintext
         */
        decryptTo(plaintext: Uint8Array, ciphertext: Uint8Array, tag?: Uint8Array | null): number
    }
}
/**
 * UTF8 processing function ported from golang standard library
 */
declare module "ejs/unicode/utf8" {
    /**
     * int32 number used to store unicode characters
     */
    export type Rune = number

    /**
     * the "error" Rune or "Unicode replacement character"
     * 65533
     */
    export const RuneError: Rune = 65533
    /**
     * characters below RuneSelf are represented as themselves in a single byte.
     * 0x80
     */
    export const RuneSelf: Rune = 0x80
    /**
     * Maximum valid Unicode code point.
     * 1114111
     */
    export const MaxRune: Rune = 1114111
    /**
     * maximum number of bytes of a UTF-8 encoded Unicode character.
     * 4
     */
    export const UTFMax = 4

    /**
     * Encode rune to Uint8Array
     */
    export class UTF8Builder {
        /**
         * 
         * @param buf optional buffer
         */
        constructor(buf?: Uint8Array, len?: number)
        /**
         * Returns the encoded string
         */
        toString(): string
        /**
         * Returns the encoded byte array
         */
        toBuffer(): Uint8Array | undefined
        /**
         * Returns the encoded length in bytes
         */
        readonly length: number
        /**
         * encoded buffer
         */
        readonly buffer?: Uint8Array
        /**
         * reset buffer
         */
        reset(buffer?: Uint8Array, len?: number): UTF8Builder
        /**
         * Encode rune to end of buffer.
         * If the rune is out of range, it appends the encoding of RuneError.
         */
        append(...r: Array<Rune>): UTF8Builder
    }
    /**
     * Writes into p (which must be large enough) the UTF-8 encoding of the rune.
     * If the rune is out of range, it writes the encoding of RuneError.
     * It returns the number of bytes written.
     */
    export function encode(p: Uint8Array, r: Rune): number
    /**
     * Calculate how many bytes are needed to encode r, 
     * and return the bytes needed to encode RuneError if r is invalid
     */
    export function encodeLen(r: Rune): number
    /**
     * Returns the number of bytes required to encode the rune.
     * It returns -1 if the rune is not a valid value to encode in UTF-8.
     */
    export function len(r: Rune): number

    /**
     * Unpacks the last UTF-8 encoding in p and returns the rune and
     * its width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if
     * the encoding is invalid, it returns (RuneError, 1). Both are impossible
     * results for correct, non-empty UTF-8.
     * 
     * An encoding is invalid if it is incorrect UTF-8, encodes a rune that is
     * out of range, or is not the shortest possible UTF-8 encoding for the
     * value. No other validation is performed.
     */
    export function decodeLast(p: Uint8Array | string): [/*r:*/Rune, /*size:*/ number]

    /**
     * Reports whether the byte could be the first byte of an encoded,
     * possibly invalid rune. Second and subsequent bytes always have the top two
     * bits set to 10.
     */
    export function isStart(b: Rune): boolean

    /**
     * Unpacks the first UTF-8 encoding in p and returns the rune and
     * its width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if
     * the encoding is invalid, it returns (RuneError, 1). Both are impossible
     * results for correct, non-empty UTF-8.
     * 
     * An encoding is invalid if it is incorrect UTF-8, encodes a rune that is
     * out of range, or is not the shortest possible UTF-8 encoding for the
     * value. No other validation is performed.
     */
    export function decode(p: Uint8Array | string): [/*r:*/Rune, /*size:*/ number]

    /**
     * Reports whether the bytes in p begin with a full UTF-8 encoding of a rune.
     * An invalid encoding is considered a full Rune since it will convert as a width-1 error rune.
     */
    export function isFull(p: Uint8Array | string): boolean

    /**
     * Returns the number of runes in p. Erroneous and short
     * encodings are treated as single runes of width 1 byte.
     */
    export function count(p: Uint8Array | string): number
    /**
     * Reports whether p consists entirely of valid UTF-8-encoded runes.
     */
    export function isValid(p: Uint8Array | string): boolean
    /**
     * Reports whether r can be legally encoded as UTF-8.
     * Code points that are out of range or a surrogate half are illegal.
     */
    export function isRune(r: Rune): boolean
    /**
     * callback function called for each utf8 rune
     * @param cb If true is returned, stop continuing the callback
     */
    export function forEach(p: Uint8Array, cb: (r: Rune, offset: number) => void | boolean)
}
/**
 * String conversion function ported from golang standard library
 */
declare module "ejs/strconv" {
    import { Rune } from "ejs/unicode/utf8";
    export class NumError extends Error {
        constructor(public opts: NumErrorOptions)
        unwrap(): any
    }
    /**
     * indicates that a value is out of range for the target type.
     */
    export const ErrRange = new RangeError("value out of range")

    /**
     * indicates that a value does not have the right syntax for the target type.
     */
    export const ErrSyntax = new Error("invalid syntax")
    /**
     * Convert v to a string Uint8Array, useful for getting utf8 byte data of string
     */
    export function toBuffer(v: string): Uint8Array
    /**
     * returns "true" or "false" according to the value of b.
     */
    export function formatBool(b: any): string
    /**
     * returns the boolean value represented by the string.
     * It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False.
     * Any other value returns undefined.
     * 
     * @throws NumError
     */
    export function parseBool(str: string): boolean

    /**
     * returns the string representation of i uin the given base,
     * for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'
     * for digit values >= 10.
     */
    export function formatUint(i: number, base = 10): string
    /**
     * returns the string representation of i in the given base,
     * for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'
     * for digit values >= 10.
     */
    export function formatInt(i: number, base = 10): string
    /**
     * Like parseInt but for unsigned numbers.
     * A sign prefix is not permitted.
     * @param s 
     * @param base If the base argument is 0, the true base is implied by the string's prefix following the sign (if present): 2 for "0b", 8 for "0" or "0o", 16 for "0x", and 10 otherwise. Also, for argument base 0 only, underscore characters are permitted as defined by the syntax for integer literals.
     * @param bitSize The bitSize argument specifies the integer type that the result must fit into. Bit sizes 0, 8, 16, 32, and 64 correspond to int, int8, int16, int32, and int64. If bitSize is below 0 or above 64, an error is throw.
     */
    export function parseUint(s: string | Uint8Array, base = 0, bitSize = 64): number
    /**
     * Like parseInt but for unsigned numbers.
     * A sign prefix is not permitted.
     * @param s 
     * @param base If the base argument is 0, the true base is implied by the string's prefix following the sign (if present): 2 for "0b", 8 for "0" or "0o", 16 for "0x", and 10 otherwise. Also, for argument base 0 only, underscore characters are permitted as defined by the syntax for integer literals.
     * @param bitSize The bitSize argument specifies the integer type that the result must fit into. Bit sizes 0, 8, 16, 32, and 64 correspond to int, int8, int16, int32, and int64. If bitSize is below 0 or above 64, an error is throw.
     * @returns Returns number for valid values ​​within Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER, and returns as a string for values ​​outside this range.
     */
    export function parseUint(s: string | Uint8Array, base = 0, bitSize = 64, toString = true): number | string
    /**
     * Interprets a string s in the given base (0, 2 to 36) and bit size (0 to 64) and returns the corresponding value i.
     * The string may begin with a leading sign: "+" or "-".
     * @param s 
     * @param base If the base argument is 0, the true base is implied by the string's prefix following the sign (if present): 2 for "0b", 8 for "0" or "0o", 16 for "0x", and 10 otherwise. Also, for argument base 0 only, underscore characters are permitted as defined by the syntax for integer literals.
     * @param bitSize The bitSize argument specifies the integer type that the result must fit into. Bit sizes 0, 8, 16, 32, and 64 correspond to int, int8, int16, int32, and int64. If bitSize is below 0 or above 64, an error is throw.
     */
    export function parseInt(s: string | Uint8Array, base = 0, bitSize = 64): number
    /**
     * Interprets a string s in the given base (0, 2 to 36) and bit size (0 to 64) and returns the corresponding value i.
     * The string may begin with a leading sign: "+" or "-".
     * @param s 
     * @param base If the base argument is 0, the true base is implied by the string's prefix following the sign (if present): 2 for "0b", 8 for "0" or "0o", 16 for "0x", and 10 otherwise. Also, for argument base 0 only, underscore characters are permitted as defined by the syntax for integer literals.
     * @param bitSize The bitSize argument specifies the integer type that the result must fit into. Bit sizes 0, 8, 16, 32, and 64 correspond to int, int8, int16, int32, and int64. If bitSize is below 0 or above 64, an error is throw.
     * @returns Returns number for valid values ​​within Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER, and returns as a string for values ​​outside this range.
     */
    export function parseInt(s: string | Uint8Array, base = 0, bitSize = 64, toString = true): number | string
    /**
     * equivalent to formatInt(i, 10).
     */
    export function itoa(i: number): string
    /**
     * equivalent to parseInt(s, 10, 0), converted to type int.
     */
    export function atoi(s: string | Uint8Array): number
    /**
     * equivalent to parseInt(s, 10, 0), converted to type int.
     * @returns Returns number for valid values ​​within Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER, and returns as a string for values ​​outside this range.
     */
    export function atoi(s: string | Uint8Array, toString = true): string

    /**
     * Reports whether the rune is defined as a Graphic by Unicode. Such
     * characters include letters, marks, numbers, punctuation, symbols, and
     * spaces, from categories L, M, N, P, S, and Zs.
     */
    export function isGraphic(r: Rune): boolean
    /**
     * Reports whether the rune is defined as printable by Go, with
     * the same definition as unicode.IsPrint: letters, numbers, punctuation,
     * symbols and ASCII space.
     */
    export function isPrint(r: Rune): boolean

    /**
     * Reports whether the string s can be represented unchanged as 
     * a single-line backquoted string without control characters other than tab.
     */
    export function canBackquote(s: string | Uint8Array): boolean
    /**
     * Returns a double-quoted string literal representing s. The
     * returned string uses escape sequences (\t, \n, \xFF, \u0100) for
     *  control characters and non-printable characters as defined by
     * isPrint.
     */
    export function quote(s: string | Uint8Array): string
    /**
     * Returns a double-quoted string literal representing s. The
     * returned string uses escape sequences (\t, \n, \xFF, \u0100) for
     *  control characters and non-printable characters as defined by
     * isPrint.
     */
    export function quote(s: string | Uint8Array, bytes = true): Uint8Array
    /**
     * returns a double-quoted string literal representing s. 
     * The returned string uses escape sequences (\t, \n, \xFF, \u0100) for non-ASCII characters 
     * and non-printable characters as defined by isPrint.
     */
    export function quoteToASCII(s: string | Uint8Array): string
    /**
     * returns a double-quoted string literal representing s. 
     * The returned string uses escape sequences (\t, \n, \xFF, \u0100) for non-ASCII characters 
     * and non-printable characters as defined by isPrint.
     */
    export function quoteToASCII(s: string | Uint8Array, bytes = true): Uint8Array
    /**
     * Returns a double-quoted string literal representing s. 
     * The returned string leaves Unicode graphic characters, as defined by IsGraphic, 
     * unchanged and uses escape sequences (\t, \n, \xFF, \u0100) for non-graphic characters.
     */
    export function quoteToGraphic(s: string | Uint8Array): string
    /**
     * Returns a double-quoted string literal representing s. 
     * The returned string leaves Unicode graphic characters, as defined by IsGraphic, 
     * unchanged and uses escape sequences (\t, \n, \xFF, \u0100) for non-graphic characters.
     */
    export function quoteToGraphic(s: string | Uint8Array, bytes = true): Uint8Array

    /**
     * Returns a single-quoted character literal representing the rune. 
     * The returned string uses escape sequences (\t, \n, \xFF, \u0100) for 
     * control characters and non-printable characters as defined by isPrint. 
     * if r is not a valid Unicode code point, it is interpreted as the Unicode replacement 
     * character U+FFFD.
     */
    export function quoteRune(r: Rune): string
    /**
     * Returns a single-quoted character literal representing the rune. 
     * The returned string uses escape sequences (\t, \n, \xFF, \u0100) for 
     * control characters and non-printable characters as defined by isPrint. 
     * if r is not a valid Unicode code point, it is interpreted as the Unicode replacement 
     * character U+FFFD.
     */
    export function quoteRune(r: Rune, bytes = true): Uint8Array
    /**
     * Returns a single-quoted character literal representing the rune. 
     * The returned string uses escape sequences (\t, \n, \xFF, \u0100) for non-ASCII characters 
     * and non-printable characters as defined by isPrint. If r is not a valid Unicode code point, 
     * it is interpreted as the Unicode replacement character U+FFFD.
     */
    export function quoteRuneToASCII(r: Rune): string
    /**
     * Returns a single-quoted character literal representing the rune. 
     * The returned string uses escape sequences (\t, \n, \xFF, \u0100) for non-ASCII characters 
     * and non-printable characters as defined by isPrint. If r is not a valid Unicode code point, 
     * it is interpreted as the Unicode replacement character U+FFFD.
     */
    export function quoteRuneToASCII(r: Rune, bytes = true): Uint8Array
    /**
     * Returns a single-quoted character literal representing the rune. 
     * If the rune is not a Unicode graphic character, as defined by isGraphic, 
     * the returned string will use a escape sequence (\t, \n, \xFF, \u0100). 
     * If r is not a valid Unicode code point, it is interpreted as the Unicode replacement character U+FFFD.
     */
    export function quoteRuneToGraphic(r: Rune): string
    /**
     * Returns a single-quoted character literal representing the rune. 
     * If the rune is not a Unicode graphic character, as defined by isGraphic, 
     * the returned string will use a escape sequence (\t, \n, \xFF, \u0100). 
     * If r is not a valid Unicode code point, it is interpreted as the Unicode replacement character U+FFFD.
     */
    export function quoteRuneToGraphic(r: Rune, bytes = true): Uint8Array
    /**
     * Returns the quoted string (as understood by Unquote) at the prefix of s. 
     * If s does not start with a valid quoted string, throw an error.
     */
    export function quotedPrefix(s: string): string
    /**
     * Returns the quoted string (as understood by Unquote) at the prefix of s. 
     * If s does not start with a valid quoted string, throw an error.
     */
    export function quotedPrefix(s: Uint8Array): Uint8Array

    /**
     * Interprets s as a single-quoted, double-quoted,
     * or backquoted Go string literal, returning the string value
     * that s quotes.  (If s is single-quoted, it would be a 
     * character literal; Unquote returns the corresponding
     * one-character string.)
     */
    export function unquote(s: string): string
    /**
     * Interprets s as a single-quoted, double-quoted,
     * or backquoted Go string literal, returning the string value
     * that s quotes.  (If s is single-quoted, it would be a 
     * character literal; Unquote returns the corresponding
     * one-character string.)
     */
    export function unquote(s: Uint8Array): Uint8Array

    /**
     * Decodes the first character or byte in the escaped string
     * or character literal represented by the string s.
     * It returns four values:
     * 
     * 1. value, the decoded Unicode code point or byte value;
     * 2. multibyte, a boolean indicating whether the decoded character requires a multibyte UTF-8 representation;
     * 3. tail, the remainder of the string after the character; and
     * 4. an error that will be nil if the character is syntactically valid.
     * 
     * The second argument, quote, specifies the type of literal being parsed
     * and therefore which escaped quote character is permitted.
     * If set to a single quote, it permits the sequence \' and disallows unescaped '.
     * If set to a double quote, it permits \" and disallows unescaped ".
     * If set to zero, it does not permit either escape and allows both quote characters to appear unescaped.
     */
    export function unquoteChar(s: string, quote: Rune): {
        value: Rune,
        multibyte: boolean,
        tail: string,
    }
    /**
     * Decodes the first character or byte in the escaped string
     * or character literal represented by the string s.
     * It returns four values:
     * 
     * 1. value, the decoded Unicode code point or byte value;
     * 2. multibyte, a boolean indicating whether the decoded character requires a multibyte UTF-8 representation;
     * 3. tail, the remainder of the string after the character; and
     * 4. an error that will be nil if the character is syntactically valid.
     * 
     * The second argument, quote, specifies the type of literal being parsed
     * and therefore which escaped quote character is permitted.
     * If set to a single quote, it permits the sequence \' and disallows unescaped '.
     * If set to a double quote, it permits \" and disallows unescaped ".
     * If set to zero, it does not permit either escape and allows both quote characters to appear unescaped.
     */
    export function unquoteChar(s: Uint8Array, quote: Rune): {
        value: Rune,
        multibyte: boolean,
        tail: Uint8Array,
    }
    /**
     * used to build string
     */
    export class StringBuilder {
        /**
         * 
         * @param buf optional buffer
         */
        constructor(buf?: Uint8Array, len?: number)
        /**
         * Returns the encoded string
         */
        toString(): string
        /**
         * Returns the encoded byte array
         */
        toBuffer(): Uint8Array | undefined
        /**
         * Returns the encoded length in bytes
         */
        readonly length: number
        /**
         * encoded buffer
         */
        readonly buffer?: Uint8Array
        /**
         * reset buffer
         */
        reset(buffer?: Uint8Array, len?: number): StringBuilder
        /**
         * Append encoded utf8 string
         */
        append(val: Uint8Array | string): StringBuilder
        /**
         * Encode rune to end of buffer.
         * If the rune is out of range, it appends the encoding of RuneError.
         */
        appendRune(...r: Array<Rune>): StringBuilder
        /**
         * Appends "true" or "false", according to the value of b, to dst
         */
        appendBool(...values: Array<any>): StringBuilder

        /**
         * Appends the string form of the integer i,
         * as generated by formatInt.
         */
        appendInt(i: number, base = 10): StringBuilder
        /**
         * Appends the string form of the integer i,
         * as generated by formatInt.
         */
        appendUint(i: number, base = 10): StringBuilder
        /**
         * Appends a double-quoted string literal representing s,
         * as generated by quote.
         */
        appendQuote(s: string | Uint8Array): StringBuilder
        /**
         * Appends a double-quoted  string literal representing s,
         * as generated by quoteToASCII.
         */
        appendQuoteToASCII(s: string | Uint8Array): StringBuilder
        /**
         * Appends a double-quoted string literal representing s, 
         * as generated by QuoteToGraphic.
         */
        appendQuoteToGraphic(s: string | Uint8Array): StringBuilder

        /**
         * Appends a single-quoted character literal representing the rune, 
         * as generated by quoteRune
         */
        appendQuoteRune(r: Rune): StringBuilder
        /**
         * Appends a single-quoted character literal representing the rune, 
         * as generated by quoteRuneToASCII
         */
        appendQuoteRuneToASCII(r: Rune): StringBuilder
        /**
         * Appends a single-quoted character literal representing the rune, 
         * as generated by quoteRuneToGraphic
         */
        appendQuoteRuneToGraphic(r: Rune): StringBuilder
    }
}
declare module "ejs/net" {
    import { YieldContext } from "ejs/sync"
    export interface AsyncOptions {
        /**
         * If true, execute asynchronous tasks in post mode, otherwise execute in send mode.
         * 
         * @remarks
         * When there are no idle threads and the number of threads reaches the upper limit, the post mode will return an error and the send mode will wait for the thread to be idle or the system to exit.
         */
        post?: boolean
    }
    export const IPv4len = 4;
    export const IPv6len = 16;
    export class AddrError extends ejs.Error {
        constructor(readonly addr: string, message: string)
    }
    /**
     * An IPMask is a bitmask that can be used to manipulate IP addresses for IP addressing and routing.
     */
    export class IPMask {
        constructor(readonly mask: Uint8Array)
        /**
         * returns the IP mask (in 4-byte form) of the IPv4 mask a.b.c.d.
         */
        static v4(a: number, b: number, c: number, d: number): IPMask
        /**
         * returns an IPMask consisting of 'ones' 1 bits followed by 0s up to a total length of 'bits' bits.
         */
        static cidr(ones: number, bits: number): IPMask | undefined
        /**
         * mask bytes length
         */
        readonly length: number

        toString(): string

        /**
         * returns the number of leading ones and total bits in the mask.
         * @remarks
         * If the mask is not in the canonical form--ones followed by zeros--then returns [0,0]
         * @returns [ones:number, bits:number]
         */
        size(): [number, number]
    }
    /**
     * An IP is a single IP address. Accept either 4-byte (IPv4) or 16-byte (IPv6) Uint8Array as input.
     */
    export class IP {
        constructor(readonly ip: Uint8Array);
        /**
         * returns the IP address (in 16-byte form) of the IPv4 address a.b.c.d.
         */
        static v4(a: number, b: number, c: number, d: number): IP

        static v4bcast = IP.v4(255, 255, 255, 255); // limited broadcast
        static v4allsys = IP.v4(224, 0, 0, 1); // all systems
        static v4allrouter = IP.v4(224, 0, 0, 2); // all routers
        static v4zero = IP.v4(0, 0, 0, 0); // all zeros

        static v6zero = new IP(
            new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        );
        static v6unspecified = new IP(
            new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        );
        static v6loopback = new IP(
            new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
        );
        static v6interfacelocalallnodes = new IP(
            new Uint8Array([0xff, 0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01]),
        );
        static v6linklocalallnodes = new IP(
            new Uint8Array([0xff, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01]),
        );
        static v6linklocalallrouters = new IP(
            new Uint8Array([0xff, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x02]),
        );
        /**
         * parses s as an IP address, returning the result.
         * @remarks
         * The string s can be in IPv4 dotted decimal ("192.0.2.1"), IPv6 ("2001:db8::68"), or IPv4-mapped IPv6 ("::ffff:192.0.2.1") form.
         * If s is not a valid textual representation of an IP address, parse returns nil.
         */
        static parse(s: string): IP | undefined

        readonly length: number
        /**
         * returns the default IP mask for the IP address ip.
         * @remarks
         * Only IPv4 addresses have default masks; DefaultMask returns undefined if ip is not a valid IPv4 address.
         */
        defaultMask(): IPMask | undefined
        /**
         * reports whether ip and o are the same IP address. An IPv4 address and that same address in IPv6 form are considered to be equal.
         */
        equal(o: IP): boolean

        /**
         * reports whether ip is a global unicast address.
         * @remarks
         * The identification of global unicast addresses uses address type
         * identification as defined in RFC 1122, RFC 4632 and RFC 4291 with
         * the exception of IPv4 directed broadcast addresses.
         * It returns true even if ip is in IPv4 private address space or
         * local IPv6 unicast address space.
         */
        readonly isGlobalUnicast: boolean
        /**
         * reports whether ip is an interface-local multicast address.
         */
        readonly isInterfaceLocalMulticast: boolean
        /**
         * reports whether ip is a link-local multicast address.
         */
        readonly isLinkLocalMulticast: boolean
        /**
         * reports whether ip is a link-local unicast address.
         */
        readonly isLinkLocalUnicast: boolean
        /**
         * reports whether ip is a loopback address.
         */
        readonly isLoopback: boolean
        /**
         * reports whether ip is a multicast address.
         */
        readonly isMulticast: boolean
        /**
         * reports whether ip is a private address, according to RFC 1918 (IPv4 addresses) and RFC 4193 (IPv6 addresses).
         */
        readonly isPrivate: boolean
        /**
         * reports whether ip is an unspecified address, either the IPv4 address "0.0.0.0" or the IPv6 address "::".
         */
        readonly isUnspecified: boolean
        /**
         * If ip is an IPv4 or IPv6 address, returns true.
         */
        readonly isValid: boolean
        /**
         * If ip is an IPv4 address, returns true.
         */
        readonly isV4: boolean
        /**
         * If ip is an IPv6 address, returns true.
         */
        readonly isV6: boolean
        /**
         * converts the IPv4 address ip to a 4-byte representation.
         * @remarks
         * If ip is not an IPv4 address, To4 returns nil.
         */
        to4(): IP | undefined

        /**
         * converts the IP address ip to a 16-byte representation.
         * @remarks
         * If ip is not an IP address (it is the wrong length), to16 returns undefined.
         */
        to16(): IP | undefined

        /**
         * returns the string form of the IP address ip.
         * @remarks 
         * It returns one of 4 forms:
         *   - "<undefined>", if ip has length 0
         *   - dotted decimal ("192.0.2.1"), if ip is an IPv4 or IP4-mapped IPv6 address
         *   - IPv6 ("2001:db8::1"), if ip is a valid IPv6 address
         *   - the hexadecimal form of ip, without punctuation, if no other cases apply
         */
        toString(): string

        /**
         * returns the result of masking the IP address ip with mask.
         */
        mask(mask: IPMask): IP | undefined
    }
    /**
     * An IPNet represents an IP network.
     */
    export class IPNet {
        constructor(readonly ip: IP, readonly mask: IPMask)
        readonly network: string
        /**
         * reports whether the network includes ip.
         */
        contains(ip: IP): boolean
        /**
         * returns the CIDR notation of n like "192.0.2.0/24" or "2001:db8::/48" as defined in RFC 4632 and RFC 4291.
         * 
         * @remarks
         * If the mask is not in the canonical form, it returns the string which consists of an IP address, followed by a slash character and a mask expressed as hexadecimal form with no punctuation like "198.51.100.0/c000ff00".
         */
        toString(): string
    }

    /**
     * parses s as a CIDR notation IP address and prefix length, like "192.0.2.0/24" or "2001:db8::/32", as defined in RFC 4632 and RFC 4291.
     * 
     * @remarks
     * It returns the IP address and the network implied by the IP and prefix length.
     * 
     * For example, parseCIDR("192.0.2.1/24") returns the IP address 192.0.2.1 and the network 192.0.2.0/24.
     * 
     */
    export function parseCIDR(s: string): [IP, IPNet] | undefined

    /**
     * combines host and port into a network address of the
     * form "host:port". If host contains a colon, as found in literal
     * IPv6 addresses, then JoinHostPort returns "[host]:port".
     */
    export function joinHostPort(host: string, port: string | number): string
    /**
     * @throws AddrError
     * 
     * SplitHostPort splits a network address of the form "host:port",
     * "host%zone:port", "[host]:port" or "[host%zone]:port" into host or
     * host%zone and port.
     * 
     *  A literal IPv6 address in hostport must be enclosed in square
     * brackets, as in "[::1]:80", "[::1%lo0]:80".
     * 
     */
    export function splitHostPort(hostport: string): [string, string]

    export class NetError extends ejs.Error {
        constructor(message: string);
        /**
         * If true, it means that this is an error that occurred when connecting to the server.
         */
        connect?: boolean
        /**
         * If true, it means that this is an error that occurred while reading the data.
         */
        read?: boolean
        /**
         * If true it means this is an error that occurred while writing data
         */
        write?: boolean

        /**
         * If true, it means that the connection/read/write timeout occurred
         */
        timeout?: boolean
        /**
         * If true, it means that read/write encountered eof
         */
        eof?: boolean

        /**
         * Request canceled
         */
        cancel?: boolean
    }
    export interface Addr {
        /**
         * name of the network (for example, "tcp", "udp")
         */
        readonly network: string
        /**
         * string form of address (for example, "192.0.2.1:25", "[2001:db8::1]:80")
         */
        readonly address: string
    }

    export type AbortListener = (this: AbortSignal, reason: any) => any
    /** 
     * A signal object that allows you to communicate with a request and abort it if required via an AbortController object.
     */
    export class AbortSignal {
        private aborted_ = false
        /** 
         * Returns true if this AbortSignal's AbortController has signaled to abort,
         * and false otherwise. 
         */
        readonly aborted(): boolean
        readonly reason(): any
        addEventListener(listener: AbortListener): void
        removeEventListener(listener: AbortListener): void
        /** Throws this AbortSignal's abort reason, if its AbortController has
       * signaled to abort; otherwise, does nothing. */
        throwIfAborted(): void
    }
    /**
     * A controller object that allows you to abort one or more requests as and when desired.
     */
    export class AbortController {
        /** 
         * Returns the AbortSignal object associated with this object. 
         */
        readonly signal: AbortSignal
        /** 
         * Invoking this method will set this object's AbortSignal's aborted flag and
         * signal to any observers that the associated activity is to be aborted. 
         */
        abort(reason?: any): void
    }

    export class ResolverError extends NetError { }
    export interface ResolverOptions {
        /**
         * upstream domain name server ip
         */
        nameserver?: Array<string>
        /**
         * Whether to load the dns server set by the system default settings
         * @remarks
         * Under Linux, the settings in /etc/resolv.conf will be loaded.
         * @default true
         */
        system?: boolean
    }
    export interface ResolveOptions {
        /**
         * Name to be queried
         */
        name: string
        /**
         * A signal that can be used to cancel resolve
         */
        signal?: AbortSignal
        /**
         * If not set, ipv4 and ipv6 will be queried at the same time, but only the result queried first will be called back.
         */
        v6?: boolean
    }
    export interface ResolveResult {
        ip?: Array<string>
        v6?: boolean
    }
    /**
     * Used to resolve domain names supporting A or AAAA
     */
    export class Resolver {
        static setDefault(v?: Resolver)
        static getDefault(): Resolver
        static hasDefault(): boolean

        constructor(opts: deps.ResolverOptions = { system: true })
        readonly isClosed: boolean
        close(): void
        /**
         * Query the A/AAAA record of a domain name
         * @param opts Query options
         * @param cb Query result callback
         */
        resolve(opts: ResolveOptions, cb: (result?: ResolveResult, e?: any) => void): void
    }

    /**
     * Set tls debugging level
     * 
     * - 0 No debug (default level)
     * - 1 Error 
     * - 2 State change 
     * - 3 Informational 
     * - 4 Verbose
     */
    export function mbedtlsDebug(level?: number): void
    /**
     * Get tls debugging level
     * 
     * - 0 No debug (default level)
     * - 1 Error 
     * - 2 State change 
     * - 3 Informational 
     * - 4 Verbose
     */
    export function mbedtlsDebug(): number
    /**
     * tls 1.2
     *  - RFC 5246: ProtocolVersion version = { 3, 3 };     // TLS v1.2
     *  - major = Math.floor(v/100)
     *  - minor= v%100
     */
    export const Tls12 = 303
    /**
     * tls 1.3
     *  - RFC 8446: see section 4.2.1     // TLS v1.2
     *  - major = Math.floor(v/100)
     *  - minor= v%100
     */
    export const Tls13 = 304

    export interface TlsConfig {
        serverName?: string
        /**
         * @default Tls12
         */
        minVersion?: number
        /**
         * @default Tls12
         */
        maxVersion?: number

        /**
         * root ca(x509)
         * 
         * System ca (linux should load /etc/ssl/certs/ca-certificates.crt)
         */
        certificate?: Array<string>

        /**
         * If true do not verify the certificate
         */
        insecure?: boolean
        /**
         * Print debugging information to stdout
         */
        debug?: boolean
    }
    /**
     * The root certificate used by the script
     */
    export class RootCertificate {
        private constructor() { }
        /**
         * Replace the root certificate used by the script
         * @param v 
         */
        static set(v: string | undefined): void
        /**
         * Returns the root certificate, which will be automatically loaded if it has not been loaded yet.
         */
        static getSync(): string
        /**
         * Returns the root certificate, which will be automatically loaded if it has not been loaded yet.
         */
        static get(cb: (ca?: string, e?: any) => void): void
        /**
         * Returns the root certificate, which will be automatically loaded if it has not been loaded yet.
         */
        static get(opts: AsyncOptions, cb: (ca?: string, e?: any) => void): void
        /**
         * Returns the root certificate, which will be automatically loaded if it has not been loaded yet.
         */
        static get(co: YieldContext, opts?: AsyncOptions): string
        /**
         * Returns the root certificate, which will be automatically loaded if it has not been loaded yet.
         */
        static get(opts?: AsyncOptions): Promise<string>
    }
    /**
     * Conn is a generic stream-oriented network connection.
     */
    export interface Conn {
        readonly remoteAddr: Addr
        readonly localAddr: Addr
        /**
         * Returns whether the connection has been closed
         */
        readonly isClosed: boolean
        /**
         * Close the connection and release resources
         */
        close(): void
        /**
         * Callback when an error occurs
         */
        onError?: (this: Conn, e: any) => void
        /**
         * Write data returns the actual number of bytes written
         * @remarks
         * This function either writes all the data or none of the bytes.
         * 
         * @param data data to write
         * @returns If undefined is returned, it means that the write buffer is full and you need to wait for the onWritable callback before continuing to write data.
         */
        write(data: string | ejs.BufferData): number | undefined
        /**
         * Callback whenever the write buffer changes from unwritable to writable
         */
        onWritable?: (this: Conn) => void
        /**
         * Write buffer size
         */
        maxWriteBytes: number
        /**
         * Callback when a message is received. If set to undefined, it will stop receiving data.
         * @remarks
         * The data passed in the callback is only valid in the callback function. If you want to continue to access it after the callback ends, you should create a copy of it in the callback.
         */
        onMessage?: (this: Conn, data: Uint8Array) => void
        /**
         * Callback when there is data to read
         */
        onReadable?: (this: Conn, r: Readable) => void
        /**
         * Read buffer
         * @remarks
         * If not set, a buffer of size 32k will be automatically created when reading.
         */
        buffer?: Uint8Array
    }
    export interface Listener {
        readonly addr: Addr
        readonly isClosed: boolean
        close(): void
        onAccept?: (this: Listener, c: BaseTcpConn) => void
        onError?: (this: Listener, e: any) => void
    }
    /**
     * Readable network device for reading ready data
     */
    export interface Readable {
        /**
         * Returns the currently ready data length
         */
        readonly length: number
        /**
         * Read as much data as possible into dst, returning the actual bytes read
         * @returns the actual read data length
         */
        read(dst: ejs.BufferData): number
        /**
         * Copies as much data as possible to dst, returning the actual copied bytes. 
         * This function does not cause the Readable.length property to change
         * @returns the actual copied data length
         */
        copy(dst: ejs.BufferData, skip?: number): number
        /**
         * Discard data of specified length
         * @returns the actual discarded data length
         */
        drain(n: number): number
    }
    export class BaseTcpConn implements Conn {
        private constructor() { }
        readonly remoteAddr: Addr
        readonly localAddr: Addr

        /**
         * Returns whether the connection has been closed
         */
        readonly isClosed: boolean

        /**
         * There is no need to explicitly call this function unless you want to close the connection immediately
         */
        close(): void
        /**
         * Will be called back when the connection is closed
         */
        onClose?: (this: BaseTcpConn) => void
        /**
         * Callback when an error occurs
         */
        onError?: (this: BaseTcpConn, e: any) => void
        /**
         * Write data returns the actual number of bytes written
         * 
         * @param data data to write
         * @returns If undefined is returned, it means that the write buffer is full and you need to wait for the onWritable callback before continuing to write data.
         */
        write(data: string | ejs.BufferData): number | undefined
        /**
         * Callback whenever the write buffer changes from unwritable to writable
         */
        onWritable?: (this: BaseTcpConn) => void
        /**
         * Write buffer size
         */
        maxWriteBytes: number
        /**
         * Callback when a message is received. If set to undefined, it will stop receiving data.
         * @remarks
         * The data passed in the callback is only valid in the callback function. If you want to continue to access it after the callback ends, you should create a copy of it in the callback.
         */
        onMessage?: (this: BaseTcpConn, data: Uint8Array) => void

        /**
         * Read buffer
         * @remarks
         * If not set, a buffer of size 32k will be automatically created when reading.
         */
        buffer?: Uint8Array
        /**
         * Callback when there is data to read
         */
        onReadable?: (this: BaseTcpConn, r: Readable) => void
    }
    export class BaseTcpListener implements Listener {
        private constructor() { }
        readonly addr: Addr
        close(): void
        readonly isClosed: boolean
        onAccept?: (this: BaseTcpListener, c: TcpConn) => void
        onError?: (this: BaseTcpListener, e: any) => void
    }
    export class TcpError extends NetError { }
    export class TcpConn extends BaseTcpConn { }
    export class TcpListener extends BaseTcpListener { }

    export class UnixError extends NetError { }
    export class UnixConn extends BaseTcpConn { }
    export class UnixListener extends BaseTcpListener { }
    /**
     * x509 certificate
     */
    export interface Certificate {
        cert: string
        key: string
        password?: string
    }
    export interface ServerTlsConfig {
        /**
         * @default Tls12
         */
        minVersion?: number
        /**
         * @default Tls12
         */
        maxVersion?: number

        /**
        * tls certificate
        * 
        */
        certificate: Array<Certificate>
        /**
         * Print debugging information to stdout
         */
        debug?: boolean
    }
    export interface ListenOptions {
        /**
         * name of the network (for example, "tcp", "tcp4", "tcp6", "unix")
         */
        network: string
        /**
         * string form of address (for example, "192.0.2.1:25", "[2001:db8::1]:80")
         */
        address: string
        /**
         * @default 5
         */
        backlog?: number
        /**
         * If true, a synchronous accept will be called in a separate thread to accept the connection.
         * 
         * @remarks
         * Usually there is no need to set it, but some chips and systems have bugs in asynchronous accept and cannot be used. At this time, you can only set it to true to return to synchronous mode.
         * 
         * This kind of situation exists, such as the chips and systems in West Korea. Don't ask me why I know it. It's really enviable that you haven't encountered it.
         * 
         * @default false
         */
        sync?: boolean

        /**
         * If set will use tls connection
         */
        tls?: ServerTlsConfig
    }
    /**
     * Create a listening service
     */
    export function listen(opts: ListenOptions): Listener
    /**
     * Wraps the original tcp conn with a more user-friendly read/write function
     */
    export class TcpConnReaderWriter {
        constructor(readonly conn: BaseTcpConn, buf?: ejs.BufferData)
        /**
         * Do not call conn.close. You need to call this close, otherwise the executing read/write will not be notified of the connection closing.
         */
        close(): void
        /**
         * Read data to dst
         * If 0 is returned, it means that eof is read.
         */
        read(co: YieldContext, dst: ejs.BufferData): number
        /**
         * Read data to dst
         * If 0 is returned, it means that eof is read.
         */
        read(dst: ejs.BufferData): Promise<number>
        /**
         * Read data to dst
         * If 0 is returned, it means that eof is read.
         */
        read(dst: ejs.BufferData, cb: (n?: number, e?: any) => void): void
        /**
         * Write data
         */
        write(co: YieldContext, data: string | ejs.BufferData): number
        /**
         * Write data
         */
        write(data: string | ejs.BufferData): Promise<number>
        /**
         * Write data
         */
        write(data: string | ejs.BufferData, cb: (n?: number, e?: any) => void): void
    }

    export interface DialOptions {
        /**
         * name of the network (for example, "tcp", "tcp4", "tcp6", "unix")
         */
        network: string
        /**
         * string form of address (for example, "192.0.2.1:25", "[2001:db8::1]:80")
         */
        address: string

        /**
         * A signal that can be used to cancel dialing
         */
        signal?: AbortSignal

        /**
         * If set will use tls connection
         */
        tls?: TlsConfig
    }
    /**
     * Dial a listener to create a connection for bidirectional communication
     */
    export function dial(opts: DialOptions, cb: (conn?: BaseTcpConn, e?: any) => void): void
    /**
     * Dial a listener to create a connection for bidirectional communication
     */
    export function dial(co: YieldContext, opts: DialOptions): BaseTcpConn
    /**
     * Dial a listener to create a connection for bidirectional communication
     */
    export function dial(opts: DialOptions): Promise<BaseTcpConn>

    export class UdpError extends NetError { }
    class UdpAddr implements Addr {
        /**
         * name of the network (for example, "tcp", "udp")
         */
        readonly network: string
        /**
         * string form of address (for example, "192.0.2.1:25", "[2001:db8::1]:80")
         */
        readonly address: string
        toString(): string
        constructor(ip?: string, port?: number)
    }
    /**
     * For reading ready udp data
     * @remarks
     * UDP is not a stream but a frame, which means you can only call read once per callback
     */
    export interface UdpReadable {
        /**
         * Read data from udp
         * @param dst 
         * @param remote This is the outgoing parameter, it is populated with which address the data came from
         * @returns actual number of bytes read
         */
        read(dst: ejs.BufferData, remote?: UdpAddr): number
        /**
         * whether it is readable
         */
        canRed(): boolean
    }
    export interface UdpCreateOptions {
        /**
         * @default 'udp'
         */
        network?: 'udp' | 'udp4' | 'udp6'
    }
    export interface UdpListenOptions {
        /**
         * @default 'udp'
         */
        network?: 'udp' | 'udp4' | 'udp6'
        /**
         * string form of address (for example, "192.0.2.1:25", "[2001:db8::1]:80")
         */
        address: string
    }
    export interface UdpDialOptions {
        /**
         * @default 'udp'
         */
        network?: 'udp' | 'udp4' | 'udp6'
        /**
         * string form of address (for example, "192.0.2.1:25", "[2001:db8::1]:80")
         */
        address: string
    }
    export interface UdpDialHostOptions extends UdpDialOptions {
        /**
         * A signal that can be used to cancel dialing
         */
        signal?: AbortSignal
    }
    class UdpConn {
        readonly remoteAddr: Addr
        readonly localAddr: Addr
        private constructor()
        /**
         * Create a udp socket
         */
        static create(opts?: UdpCreateOptions): UdpConn
        /**
         * Listen for udp at the specified address
         * @remarks
         * 
         * Like create() then bind()
         */
        static listen(opts: UdpListenOptions): UdpConn
        /**
         * Connect to udp server
         * @remarks
         * 
         * Like create() then connect()
         */
        static dial(opts: UdpDialOptions): UdpConn
        /**
         * Connect to udp server
         * @remarks
         * 
         * similar to dial but supports using domain names as addresses
         */
        static dialHost(opts: UdpDialHostOptions, cb: (c?: UdpConn, e?: any) => void): void
        /**
        * Connect to udp server
        * @remarks
        * 
        * similar to dial but supports using domain names as addresses
        */
        static dialHost(opts: UdpDialHostOptions): Promise<UdpConn>
        /**
        * Connect to udp server
        * @remarks
        * 
        * similar to dial but supports using domain names as addresses
        */
        static dialHost(co: YieldContext, opts: UdpDialHostOptions): UdpConn
        /**
         * 
         * Used to lock and only communicate with this address. You can think of it as a udp connection, but it will not actually create a connection, just lock the communication address.
         */
        connect(remoteAddr: UdpAddr): void
        /**
         * bind socket to local address
         */
        bind(localAddr: UdpAddr): void

        /**
         * Returns whether the connection has been closed
         */
        readonly isClosed: boolean
        /**
         * Close the connection and release resources
         */
        close(): void

        /**
         * After calling connect, you can only use write to write data
         * 
         * @param data data to write
         */
        write(data: string | ejs.BufferData): number
        /**
         * Before calling connect, you can only use writeTo to write data
         * 
         * @param data data to write
         * @param remoteAddr write target address
         */
        writeTo(data: string | ejs.BufferData, remoteAddr: UdpAddr): number

        /**
         * Write buffer size
         * @default 548
         */
        maxWriteBytes: number
        /**
         * Callback when a message is received. If set to undefined, it will stop receiving data.
         * @remarks
         * The data passed in the callback is only valid in the callback function. If you want to continue to access it after the callback ends, you should create a copy of it in the callback.
         */
        onMessage?: (this: UdpConn, data: Uint8Array) => void
        /**
         * Read buffer
         * @remarks
         * If not set, a buffer of size 32k will be automatically created when reading.
         */
        buffer?: Uint8Array
        /**
         * Callback when there is data to read
         */
        onReadable?: (this: UdpConn, r: UdpReadable) => void
    }
    /**
     * Wraps the original udp conn with a more user-friendly read function
     */
    class UdpConnReader {
        /**
         * 
         * @param conn 
         * @param bufferFrames How many frames can be cached
         * @param addr read remote addr
         */
        constructor(readonly conn: UdpConn, bufferFrames = 32, addr = false)

        /**
         * Do not call conn.close. You need to call reader's close, otherwise the executing read will not be notified of the connection closing.
         */
        close(): void
        /**
         * Read a frame of data.
         * If undefined is returned, it means that eof is read.
         */
        read(co: YieldContext, addr?: UdpAddr): Uint8Array | undefined
        /**
         * Read a frame of data.
         * If undefined is returned, it means that eof is read.
         */
        read(addr?: UdpAddr): Promise<Uint8Array | undefined>
        /**
         * Read a frame of data.
         * If undefined is returned, it means that eof is read.
         */
        read(cb: (msg?: Uint8Array, e?: any) => void): void
        /**
         * Read a frame of data.
         * If undefined is returned, it means that eof is read.
         */
        read(addr: UdpAddr, cb: (msg?: Uint8Array, e?: any) => void): void

        /**
         * After calling connect, you can only use write to write data
         * 
         * @param data data to write
         */
        write(data: string | ejs.BufferData): number
        /**
         * Before calling connect, you can only use writeTo to write data
         * 
         * @param data data to write
         * @param remoteAddr write target address
         */
        writeTo(data: string | ejs.BufferData, remoteAddr: UdpAddr): number
    }
    /**
     * Returns whether ipv6 is supported
     */
    export function isSupportV6(): boolean
    /**
     * Returns whether ipv4 is supported
     */
    export function isSupportV4(): boolean
}

/**
 * Some tools for synchronization in asynchronous code
 */
declare module "ejs/sync" {
    /**
     * Context used for the coroutine to give up the CPU
     */
    export interface YieldContext {
        /**
         * After calling function f, release the cpu so that other coroutines can run
         * @remarks
         * Usually f should be an asynchronous function, you can use coroutines to wait for the asynchronous function to complete
         */
        yield<T>(f: (notify: ResumeContext<T>) => void): T
    }

    /**
     * The context used to wake up the coroutine
     * @remarks
     * You can only call the member function once to wake up the waiting coroutine. Multiple calls will throw an exception.
     */
    export interface ResumeContext<T> {
        /**
         * Wake up the coroutine and return the value v for it
         */
        value(v: T): void
        /**
         * Wake up the coroutine and throw an exception.  
         * The exception can be caught by try catch in the coroutine
         */
        error(e?: any): void
        /**
         * Wake up the coroutine and call the function resume.  
         * The return value of resume is used as the coroutine return value.  
         * The exception thrown by resume can be caught by the coroutine.
         */
        next(resume: () => T): void
    }

    export class Coroutine {
        constructor(f: (co: YieldContext) => void)
        readonly state: 'none' | 'run' | 'yield' | 'finish'
        /**
         * run coroutine
         */
        run(): void
        /**
         * Callback after the coroutine finish
         */
        onFinish?: () => void
    }
    /**
     * new Coroutine(f).run()
     */
    export function go(f: (co: YieldContext) => void): void

    export function isYieldContext(co: any): co is YieldContext
    export type CallbackVoid = (e?: any) => void
    export type CallbackReturn<T> = (value?: T, e?: any) => void
    export type InterfaceVoid<Options> = (opts: Options, cb: CallbackVoid) => void
    export type InterfaceReturn<Options, Result> = (opts: Options, cb: CallbackReturn<Result>) => void
    export type CallbackMap<Input, Output> = (v: Input) => Output
    export interface Args<Options, CB> {
        co?: YieldContext
        cb?: CB
        opts?: Options
    }
    /**
     * Used to parse function parameters with the following signatures
     * (co: YieldContext, opts: Options) => any
     * (opts: Options) => Promise<any>
     * (opts: Options, cb: (...) => void) => Promise<any>
     * @param tag The function name to display when parsing fails
     */
    export function parseArgs<Options, CB>(tag: string, a: any, b: any): Args<Options, CB>
    /**
     * Used to parse function parameters with the following signatures
     * (co: YieldContext, opts?: Options) => any
     * (opts?: Options) => Promise<any>
     * (opts: Options, cb: (...) => void) => Promise<any>
     * (cb: (...) => void) => Promise<any>
     * @param tag The function name to display when parsing fails
     */
    export function parseOptionalArgs<Options, CB>(tag: string, a: any, b: any): Args<Options, CB>

    /**
     * Using a coroutine to call an asynchronous interface with no return value
     * 
     * @param co Coroutine context
     * @param f Asynchronous interface to be called
     * @param opts Interface parameters
     * @param ce If an error occurs, an error callback is used to wrap the error information for the caller
     */
    export function coVoid<Options>(co: YieldContext,
        f: InterfaceVoid<Options>, opts: Options,
        ce?: CallbackMap<any, any>,
    ): void
    /**
     * Calling asynchronous interface
     * 
     * @param cb Callback notification
     * @param f Asynchronous interface to be called
     * @param opts Interface parameters
     * @param ce If an error occurs, an error callback is used to wrap the error information for the caller
     */
    export function cbVoid<Options>(cb: CallbackVoid,
        f: InterfaceVoid<Options>, opts: Options,
        ce?: CallbackMap<any, any>,
    ): void
    /**
     * Convert asynchronous functions to Promise calling mode.  
     * Abbreviation for: new Promise((resolve,reject)=> cbVoid(...))
     * 
     * @param f Asynchronous interface to be called
     * @param opts Interface parameters
     * @param ce If an error occurs, an error callback is used to wrap the error information for the caller
     */
    export function asyncVoid<Options>(f: InterfaceVoid<Options>, opts: Options,
        ce?: CallbackMap<any, any>,
    ): Promise<void>
    /**
     * Automatically adapt the asynchronous function to call based on Args
     */
    export function callVoid<Options>(
        f: InterfaceVoid<Options>,
        args: Args<Options, CallbackVoid>,
        ce?: CallbackMap<any, any>,
    ): void | Promise<void>

    /**
     * Use coroutines to call asynchronous interfaces with return values
     * @param co Coroutine context
     * @param f Asynchronous interface to be called
     * @param opts Interface parameters
     * @param cv When the asynchronous function succeeds, this function is called to wrap the return value
     * @param ce If an error occurs, an error callback is used to wrap the error information for the caller
     */
    export function coReturn<Options, Result>(co: YieldContext,
        f: InterfaceReturn<Options, any>, opts: Options,
        cv?: CallbackMap<any, Result>, ce?: CallbackMap<any, any>,
    ): Result
    /**
     * Calling asynchronous interface
     * 
     * @param cb Callback notification
     * @param f Asynchronous interface to be called
     * @param opts Interface parameters
     * @param cv When the asynchronous function succeeds, this function is called to wrap the return value
     * @param ce If an error occurs, an error callback is used to wrap the error information for the caller
     */
    export function cbReturn<Options, Result>(cb: CallbackReturn<any>,
        f: InterfaceReturn<Options, any>, opts: Options,
        cv?: CallbackMap<any, Result>, ce?: CallbackMap<any, any>,
    ): void
    /**
     * Convert asynchronous functions to Promise calling mode.  
     * Abbreviation for: new Promise((resolve,reject)=> coReturn(...))
     * 
     * @param f Asynchronous interface to be called
     * @param opts Interface parameters
     * @param cv When the asynchronous function succeeds, this function is called to wrap the return value
     * @param ce If an error occurs, an error callback is used to wrap the error information for the caller
     */
    export function asyncReturn<Options, Result>(f: InterfaceReturn<Options, any>, opts: Options,
        cv?: CallbackMap<any, Result>, ce?: CallbackMap<any, any>,
    ): Promise<Result>
    /**
     * Automatically adapt the asynchronous function to call based on Args
     */
    export function callReturn<Options, Result>(
        f: InterfaceReturn<Options, any>,
        args: Args<Options, CallbackVoid>,
        cv?: CallbackMap<any, Result>, ce?: CallbackMap<any, any>,
    ): Result | Promise<Result> | void
}
/**
 * Package path implements utility routines for manipulating slash-separated paths. It's ported from golang standard library.
 */
declare module "ejs/path" {
    /**
     * Indicates a pattern was malformed.
     */
    export class BadPatternError extends Error {
        constructor(options?: ErrorOptions)
    }
    /**
     * Returns the last element of path. Trailing slashes are removed before extracting the last element. 
     * If the path is empty, base returns ".". If the path consists entirely of slashes, base returns "/".
     */
    export function base(path: string): string
    /**
     * Returns the last element of path. Trailing slashes are removed before extracting the last element. 
     * If the path is empty, base returns ".". If the path consists entirely of slashes, base returns "/".
     */
    export function base(path: Uint8Array): Uint8Array
    /**
     * Returns the shortest path name equivalent to path
     * by purely lexical processing. It applies the following rules
     * iteratively until no further processing can be done:
     * 
     * 1. Replace multiple slashes with a single slash.
     * 2. Eliminate each . path name element (the current directory).
     * 3. Eliminate each inner .. path name element (the parent directory)
     *     along with the non-.. element that precedes it.
     * 4. Eliminate .. elements that begin a rooted path:
     *     that is, replace "/.." by "/" at the beginning of a path.
     * 
     * The returned path ends in a slash only if it is the root "/".
     * 
     * If the result of this process is an empty string, clean
     * returns the string ".".
     * 
     * See also Rob Pike, “Lexical File Names in Plan 9 or Getting Dot-Dot Right,”
     * https://9p.io/sys/doc/lexnames.html
     */
    export function clean(path: string): string
    /**
     * Returns the shortest path name equivalent to path
     * by purely lexical processing. It applies the following rules
     * iteratively until no further processing can be done:
     * 
     * 1. Replace multiple slashes with a single slash.
     * 2. Eliminate each . path name element (the current directory).
     * 3. Eliminate each inner .. path name element (the parent directory)
     *     along with the non-.. element that precedes it.
     * 4. Eliminate .. elements that begin a rooted path:
     *     that is, replace "/.." by "/" at the beginning of a path.
     * 
     * The returned path ends in a slash only if it is the root "/".
     * 
     * If the result of this process is an empty string, clean
     * returns the string ".".
     * 
     * See also Rob Pike, “Lexical File Names in Plan 9 or Getting Dot-Dot Right,”
     * https://9p.io/sys/doc/lexnames.html
     */
    export function clean(path: Uint8Array): Uint8Array

    /**
     * Returns all but the last element of path, typically the path's directory.
     * After dropping the final element using Split, the path is Cleaned and trailing
     * slashes are removed.
     * If the path is empty, dir returns ".".
     * If the path consists entirely of slashes followed by non-slash bytes, dir
     * returns a single slash. In any other case, the returned path does not end in a slash.
     */
    export function dir(path: string): string
    /**
     * Returns all but the last element of path, typically the path's directory.
     * After dropping the final element using Split, the path is Cleaned and trailing
     * slashes are removed.
     * If the path is empty, dir returns ".".
     * If the path consists entirely of slashes followed by non-slash bytes, dir
     * returns a single slash. In any other case, the returned path does not end in a slash.
     */
    export function dir(path: Uint8Array): Uint8Array

    /**
     * Returns the file name extension used by path.
     * The extension is the suffix beginning at the final dot
     * in the final slash-separated element of path;
     * it is empty if there is no dot.
     */
    export function ext(path: string): string
    /**
     * Returns the file name extension used by path.
     * The extension is the suffix beginning at the final dot
     * in the final slash-separated element of path;
     * it is empty if there is no dot.
     */
    export function ext(path: Uint8Array): Uint8Array

    /**
     * Reports whether the path is absolute.
     */
    export function isAbs(path: string | Uint8Array): boolean

    /**
     *  Joins any number of path elements into a single path, separating them with slashes. 
     * Empty elements are ignored. The result is Cleaned. However, 
     * if the argument list is empty or all its elements are empty, 
     * join returns an empty string.
     */
    export function join(...elem: Array<string | Uint8Array>): string
    /**
     *  Joins any number of path elements into a single path, separating them with slashes. 
     * Empty elements are ignored. The result is Cleaned. However, 
     * if the argument list is empty or all its elements are empty, 
     * joinBuffer returns an empty string.
     */
    export function joinBuffer(...elem: Array<string | Uint8Array>): Uint8Array
    /**
     *  Joins any number of path elements into a single path, separating them with slashes. 
     * Empty elements are ignored. The result is Cleaned. However, 
     * if the argument list is empty or all its elements are empty, 
     * join returns an empty string.
     */
    export function joinArray(elem: Array<string | Uint8Array>): string
    /**
     *  Joins any number of path elements into a single path, separating them with slashes. 
     * Empty elements are ignored. The result is Cleaned. However, 
     * if the argument list is empty or all its elements are empty, 
     * join returns an empty string.
     */
    export function joinArray(elem: Array<string | Uint8Array>, toBuffer = true): Uint8Array
    /**
     * Splits path immediately following the final slash, separating it into a directory and file name component. 
     * If there is no slash in path, split returns an empty dir and file set to path. 
     * The returned values have the property that path = dir+file.
     */
    export function split(path: string): [/*dir*/ string, /*file*/ string]
    /**
     * Splits path immediately following the final slash, separating it into a directory and file name component. 
     * If there is no slash in path, split returns an empty dir and file set to path. 
     * The returned values have the property that path = dir+file.
     */
    export function split(path: Uint8Array): [/*dir*/ Uint8Array, /*file*/ Uint8Array]

    /**
     *  Match reports whether name matches the shell pattern.
     * The pattern syntax is:
     *
     *	pattern:
     *		{ term }
     *	term:
     *		'*'         matches any sequence of non-/ characters
     *		'?'         matches any single non-/ character
     *		'[' [ '^' ] { character-range } ']'
     *		            character class (must be non-empty)
     *		c           matches character c (c != '*', '?', '\\', '[')
     *		'\\' c      matches character c
     *
     *	character-range:
     *		c           matches character c (c != '\\', '-', ']')
     *		'\\' c      matches character c
     *		lo '-' hi   matches character c for lo <= c <= hi
     *
     * Match requires pattern to match all of name, not just a substring.
     * The only possible returned error is ErrBadPattern, when pattern
     * is malformed.
     */
    export function match(pattern: string | Uint8Array, name: string | Uint8Array): boolean
}
/**
 * Provides operating system-related functions, mainly reading and writing file systems
 */
declare module "ejs/os" {
    import { YieldContext } from "ejs/sync";
    export const OsError = ejs.OsError
    export interface LinkErrorOptions {
        op: string
        from: string
        to: string
        err: any
    }
    export class LinkError extends Error {
        constructor(public opts: LinkErrorOptions)
        unwrap(): any
    }
    export interface PathErrorOptions {
        op: string
        path: string
        err: any
    }
    export class PathError extends Error {
        constructor(public opts: PathErrorOptions)
        unwrap(): any
    }
    /**
     * Operation not permitted 
     */
    const EPERM: number
    /**
     * No such file or directory
     */
    const ENOENT: number
    /**
     * No such process
     */
    const ESRCH: number
    /**
     * Interrupted system call
     */
    const EINTR: number
    /**
     * I/O error
     */
    const EIO: number
    /**
     * No such device or address
     */
    const ENXIO: number
    /**
     * Argument list too long
     */
    const E2BIG: number
    /**
     * Exec format error
     */
    const ENOEXEC: number
    /**
     * Bad file number
     */
    const EBADF: number
    /**
     * No child processes
     */
    const ECHILD: number
    /**
     * Try again
     */
    const EAGAIN: number
    /**
     * Out of memory
     */
    const ENOMEM: number
    /**
     * Permission denied
     */
    const EACCES: number
    /**
     * Bad address
     */
    const EFAULT: number
    /**
     * Block device required
     */
    const ENOTBLK: number
    /**
     * Device or resource busy
     */
    const EBUSY: number
    /**
     * File exists
     */
    const EEXIST: number
    /**
     * Cross-device link
     */
    const EXDEV: number
    /**
     * No such device
     */
    const ENODEV: number
    /**
     * Not a directory
     */
    const ENOTDIR: number
    /**
     * Is a directory
     */
    const EISDIR: number
    /**
     * Invalid argument
     */
    const EINVAL: number
    /**
     * File table overflow
     */
    const ENFILE: number
    /**
     * Too many open files
     */
    const EMFILE: number
    /**
     * Not a typewriter
     */
    const ENOTTY: number
    /**
     * Text file busy
     */
    const ETXTBSY: number
    /**
     * File too large
     */
    const EFBIG: number
    /**
     * No space left on device
     */
    const ENOSPC: number
    /**
     * Illegal seek
     */
    const ESPIPE: number
    /**
     * Read-only file system
     */
    const EROFS: number
    /**
     * Too many links
     */
    const EMLINK: number
    /**
     * Broken pipe
     */
    const EPIPE: number
    /**
     * Math argument out of domain of func
     */
    const EDOM: number
    /**
     * Math result not representable
     */
    const ERANGE: number

    const EDEADLK: number
    const ENAMETOOLONG: number
    const ENOLCK: number
    const ENOSYS: number

    const ENOTEMPTY: number
    const ELOOP: number
    // const EWOULDBLOCK: number
    const ENOMSG: number
    const EIDRM: number
    const ECHRNG: number
    const EL2NSYNC: number
    const EL3HLT: number
    const EL3RST: number
    const ELNRNG: number
    const EUNATCH: number
    const ENOCSI: number
    const EL2HLT: number
    const EBADE: number
    const EBADR: number
    const EXFULL: number
    const ENOANO: number
    const EBADRQC: number
    const EBADSLT: number
    const EDEADLOCK: number
    const EBFONT: number
    const ENOSTR: number
    const ENODATA: number
    const ETIME: number
    const ENOSR: number
    const ENONET: number
    const ENOPKG: number
    const EREMOTE: number
    const ENOLINK: number
    const EADV: number
    const ESRMNT: number
    const ECOMM: number
    const EPROTO: number
    const EMULTIHOP: number
    const EDOTDOT: number
    const EBADMSG: number
    const EOVERFLOW: number
    const ENOTUNIQ: number
    const EBADFD: number
    const EREMCHG: number
    const ELIBACC: number
    const ELIBBAD: number
    const ELIBSCN: number
    const ELIBMAX: number
    const ELIBEXEC: number
    const EILSEQ: number
    const ERESTART: number
    const ESTRPIPE: number
    const EUSERS: number
    const ENOTSOCK: number
    const EDESTADDRREQ: number
    const EMSGSIZE: number
    const EPROTOTYPE: number
    const ENOPROTOOPT: number
    const EPROTONOSUPPORT: number
    const ESOCKTNOSUPPORT: number
    const EOPNOTSUPP: number
    const EPFNOSUPPORT: number
    const EAFNOSUPPORT: number
    const EADDRINUSE: number
    const EADDRNOTAVAIL: number
    const ENETDOWN: number
    const ENETUNREACH: number
    const ENETRESET: number
    const ECONNABORTED: number
    const ECONNRESET: number
    const ENOBUFS: number
    const EISCONN: number
    const ENOTCONN: number
    const ESHUTDOWN: number
    const ETOOMANYREFS: number
    const ETIMEDOUT: number
    const ECONNREFUSED: number
    const EHOSTDOWN: number
    const EHOSTUNREACH: number
    const EALREADY: number
    const EINPROGRESS: number
    const ESTALE: number
    const EUCLEAN: number
    const ENOTNAM: number
    const ENAVAIL: number
    const EISNAM: number
    const EREMOTEIO: number
    const EDQUOT: number

    const ENOMEDIUM: number
    const EMEDIUMTYPE: number
    const ECANCELED: number
    const ENOKEY: number
    const EKEYEXPIRED: number
    const EKEYREVOKED: number
    const EKEYREJECTED: number

    const EOWNERDEAD: number
    const ENOTRECOVERABLE: number

    const ERFKILL: number

    const EHWPOISON: number

    // Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified.
    const O_RDONLY: number    // open the file read-only.
    const O_WRONLY: number    // open the file write-only.
    const O_RDWR: number        // open the file read-write.
    // The remaining values may be or'ed in to control behavior.
    const O_APPEND: number  // append data to the file when writing.
    const O_CREATE: number  // create a new file if none exists.
    const O_EXCL: number    // used with O_CREATE, file must not exist.
    const O_SYNC: number     // open for synchronous I/O.
    const O_TRUNC: number    // truncate regular writable file when opened.


    const SEEK_CUR: number
    const SEEK_END: number
    const SEEK_SET: number

    export interface AsyncOptions {
        /**
         * If true, execute asynchronous tasks in post mode, otherwise execute in send mode.
         * 
         * @remarks
         * When there are no idle threads and the number of threads reaches the upper limit, the post mode will return an error and the send mode will wait for the thread to be idle or the system to exit.
         */
        post?: boolean
    }
    export interface OpenFileSyncOptions {
        name: string
        flags?: number
        perm?: number
    }
    export interface OpenFileOptions extends OpenFileSyncOptions, AsyncOptions { }

    export interface FileInfo {
        /**
         * base name of the file
         */
        name(): string
        /**
         * length in bytes for regular files
         */
        size(): number
        /**
         * file mode bits
         */
        mode(): number
        /**
         * modification time
         */
        modTime(): Date
        /**
         * abbreviation for mode().isDir()
         */
        isDir(): boolean
        /**
         * abbreviation for mode().isRegular()
         */
        isRegular(): boolean
    }

    export interface SeekSyncOptions {
        offset: number
        whence: number
    }
    export interface SeekOptions extends SeekSyncOptions, AsyncOptions { }
    export interface ReadOptions extends AsyncOptions {
        dst: ejs.BufferData
    }
    export interface ReadAtSyncOptions {
        dst: ejs.BufferData
        offset: number
    }
    export interface ReadAtOptions extends ReadAtSyncOptions, AsyncOptions { }
    export interface WriteOptions extends AsyncOptions {
        src: ejs.BufferData | string
    }
    export interface WriteAtSyncOptions {
        src: ejs.BufferData | string
        offset: number
    }
    export interface WriteAtOptions extends WriteAtSyncOptions, AsyncOptions { }
    export interface FileChmodAsyncOptions extends AsyncOptions {
        perm: number
    }
    export interface FileTruncateOptions extends AsyncOptions {
        size: number
    }
    export interface FileChownSyncOptions {
        fd: any
        uid: number
        gid: number
    }
    export interface FileChownOptions extends FileChownSyncOptions, AsyncOptions { }
    export interface FileReadDirOptions extends AsyncOptions {
        /**
         * If greater than 0, the maximum length of the returned array is n
         */
        n?: number
    }

    export interface CreateTempSyncOptions {
        pattern: string
        /**
         * @default tempDir()
         */
        dir?: string

        /**
         * @default 0o600
         */
        perm?: number
    }
    export interface CreateTempOptions extends CreateTempSyncOptions, AsyncOptions { }

    export interface OpenFileSyncOptions {
        name: string
        /**
         * @default O_RDONLY
         */
        flags?: number
        /**
         * @default 0
         */
        perm?: number
    }
    export interface OpenFileOptions extends OpenFileSyncOptions, AsyncOptions { }

    export interface CreateFileSyncOptions {
        name: string
        /**
         * @default O_RDONLY | O_CREATE | O_TRUNC
         */
        flags?: number
        /**
         * @default 0o666
         */
        perm?: number
    }
    export interface CreateFileOptions extends CreateFileSyncOptions, AsyncOptions { }
    export class File {
        private constructor()
        /**
         * creates a new temporary file in the temp directory
         * @throws PathError
         */
        static createTempSync(pattern: string): File
        /**
         * creates a new temporary file in the directory opts.dir
         * @throws PathError
         */
        static createTempSync(opts: CreateTempSyncOptions): File
        /**
         * Similar to createTempSync but called asynchronously, notifying the result in cb
         */
        static createTemp(pattern: string, cb: (f?: File, e?: PathError) => void): void
        /**
         * Similar to createTempSync but called asynchronously, notifying the result in cb
         */
        static createTemp(opts: CreateTempOptions, cb: (f?: File, e?: PathError) => void): void
        /**
         * creates a new temporary file in the temp directory
         * @throws PathError
         */
        static createTemp(co: YieldContext, pattern: string): File
        /**
         * creates a new temporary file in the directory opts.dir
         * @throws PathError
         */
        static createTemp(co: YieldContext, opts: CreateTempOptions): File
        /**
         * creates a new temporary file in the temp directory
         * @throws PathError
         */
        static createTemp(pattern: string): Promise<File>
        /**
         * creates a new temporary file in the directory opts.dir
         * @throws PathError
         */
        static createTemp(opts: CreateTempOptions): Promise<File>

        /**
         * Open the file as read-only (O_RDONLY)
         * @throws PathError
         */
        static openSync(name: string): File
        /**
         * Open the file
         * @throws PathError
         */
        static openSync(opts: OpenFileSyncOptions): File
        /**
         * Similar to openSync but called asynchronously, notifying the result in cb
         */
        static open(name: string, cb: (f?: File, e?: PathError) => void): void
        /**
         * Similar to openSync but called asynchronously, notifying the result in cb
         */
        static open(opts: OpenFileOptions, cb: (f?: File, e?: PathError) => void): void
        /**
         * Open the file as read-only (O_RDONLY)
         * @throws PathError
         */
        static open(co: YieldContext, name: string): File
        /**
         * Open the file
         * @throws PathError
         */
        static open(co: YieldContext, opts: OpenFileOptions): File
        /**
         * Open the file as read-only (O_RDONLY)
         * @throws PathError
         */
        static open(name: string): Promise<File>
        /**
         * Open the file
         * @throws PathError
         */
        static open(opts: OpenFileOptions): Promise<File>

        /**
         * Create a new file
         * @throws PathError
         */
        static createSync(name: string): File
        /**
         * Create a new file
         * @throws PathError
         */
        static createSync(opts: CreateFileSyncOptions): File
        /**
         * Similar to createSync but called asynchronously, notifying the result in cb
         */
        static create(name: string, cb: (f?: File, e?: PathError) => void): void
        /**
         * Similar to createSync but called asynchronously, notifying the result in cb
         */
        static create(opts: CreateFileSyncOptions, cb: (f?: File, e?: PathError) => void): void
        /**
         * Create a new file
         * @throws PathError
         */
        static create(co: YieldContext, name: string): File
        /**
         * Create a new file
         * @throws PathError
         */
        static create(co: YieldContext, opts: CreateFileSyncOptions): File
        /**
         * Create a new file
         * @throws PathError
         */
        static create(name: string): Promise<File>
        /**
         * Create a new file
         * @throws PathError
         */
        static create(opts: CreateFileSyncOptions): Promise<File>

        /**
         * close file
         */
        close(): void
        readonly isClosed: boolean
        /**
         * @returns the archive name passed when opening
         */
        name(): string
        /**
         * returns the FileInfo describing file.
         * @throws PathError
         */
        statSync(): FileInfo
        /**
         * Similar to statSync but called asynchronously, notifying the result in cb
         */
        stat(cb: (info?: FileInfo, e?: PathError) => void): void
        /**
         * Similar to statSync but called asynchronously, notifying the result in cb
         */
        stat(opts: AsyncOptions, cb: (info?: FileInfo, e?: PathError) => void): void
        /**
         * returns the FileInfo describing file.
         * @throws PathError
         */
        stat(co: YieldContext, opts?: AsyncOptions): FileInfo
        /**
         * returns the FileInfo describing file.
         * @throws PathError
         */
        stat(opts?: AsyncOptions): Promise<FileInfo>
        /**
         * Sets the offset for the next Read or Write on file to offset
         * @throws PathError
         */
        seekSync(opts: SeekSyncOptions): number
        /**
         * Similar to seekSync but called asynchronously, notifying the result in cb
         */
        seek(opts: SeekOptions, cb: (offset?: number, e?: PathError) => void): void
        /**
         * Sets the offset for the next Read or Write on file to offset
         * @throws PathError
         */
        seek(co: YieldContext, opts: SeekOptions): number
        /**
         * Sets the offset for the next Read or Write on file to offset
         * @throws PathError
         */
        seek(opts: SeekOptions): Promise<number>
        /**
         * Read data to dst
         * @throws PathError
         * @returns the actual length of bytes read, or 0 if eof is read
         */
        readSync(dst: ejs.BufferData): number
        /**
         * Similar to readSync but called asynchronously, notifying the result in cb
         */
        read(opts: ReadOptions | ejs.BufferData, cb: (n?: number, e?: PathError) => void): void
        /**
         * Read data to dst
         * @throws PathError
         * @returns the actual length of bytes read, or 0 if eof is read
         */
        read(co: YieldContext, opts: ReadOptions | ejs.BufferData): number
        /**
         * Read data to dst
         * @throws PathError
         * @returns the actual length of bytes read, or 0 if eof is read
         */
        read(opts: ReadOptions | ejs.BufferData): Promise<number>
        /**
         * Read the data at the specified offset
         * @throws PathError
         * @returns the actual length of bytes read, or 0 if eof is read
         */
        readAtSync(opts: ReadAtSyncOptions): number
        /**
         * Similar to readAtSync but called asynchronously, notifying the result in cb
         */
        readAt(opts: ReadAtOptions, cb: (n?: number, e?: PathError) => void): void
        /**
         * Read the data at the specified offset
         * @throws PathError
         * @returns the actual length of bytes read, or 0 if eof is read
         */
        readAt(co: YieldContext, opts: ReadAtOptions): number
        /**
         * Read the data at the specified offset
         * @throws PathError
         * @returns the actual length of bytes read, or 0 if eof is read
         */
        readAt(opts: ReadAtOptions): Promise<number>

        /**
         * Write data
         * @throws PathError
         * @returns the actual length of bytes write
         */
        writeSync(data: ejs.BufferData | string): number
        /**
         * Similar to writeSync but called asynchronously, notifying the result in cb
         */
        write(opts: WriteOptions | ejs.BufferData | string, cb: (n?: number, e?: PathError) => void): void
        /**
         * Write data
         * @throws PathError
         * @returns the actual length of bytes write
         */
        write(co: YieldContext, opts: WriteOptions | ejs.BufferData | string): number
        /**
         * Write data
         * @throws PathError
         * @returns the actual length of bytes write
         */
        write(opts: WriteOptions | ejs.BufferData | string): Promise<number>
        /**
         * Write the data at the specified offset
         * @throws PathError
         * @returns the actual length of bytes write
         */
        writeAtSync(opts: WriteAtSyncOptions): number
        /**
         * Similar to writeAtSync but called asynchronously, notifying the result in cb
         */
        writeAt(opts: WriteAtOptions, cb: (n?: number, e?: PathError) => void): void
        /**
         * Write the data at the specified offset
         * @throws PathError
         * @returns the actual length of bytes write
         */
        writeAt(co: YieldContext, opts: WriteAtOptions): number
        /**
         * Write the data at the specified offset
         * @throws PathError
         * @returns the actual length of bytes write
         */
        writeAt(opts: WriteAtOptions): Promise<number>
        /**
         * Commits the current contents of the file to stable storage.
         * Typically, this means flushing the file system's in-memory copyof recently written data to disk.
         * @throws PathError
         */
        syncSync(): void
        /**
         * Similar to syncSync but called asynchronously, notifying the result in cb
         */
        sync(cb: (e?: PathError) => void): void
        /**
         * Similar to syncSync but called asynchronously, notifying the result in cb
         */
        sync(opts: AsyncOptions, cb: (e?: PathError) => void): void
        /**
         * Commits the current contents of the file to stable storage.
         * Typically, this means flushing the file system's in-memory copyof recently written data to disk.
         * @throws PathError
         */
        sync(co: YieldContext, opts?: AsyncOptions): void
        /**
         * Commits the current contents of the file to stable storage.
         * Typically, this means flushing the file system's in-memory copyof recently written data to disk.
         * @throws PathError
         */
        sync(opts?: AsyncOptions): Promise<void>

        /**
         * changes the current working directory to the file, which must be a directory.
         * @throws PathError
         */
        chdir(): void
        /**
         * changes the mode of the file to mode
         * @throws PathError
         */
        chmodSync(perm: number): void
        /**
         * Similar to chmodSync but called asynchronously, notifying the result in cb
         */
        chmod(opts: FileChmodAsyncOptions, cb: (PathError?: any) => void): void
        /**
         * changes the mode of the file to mode
         * @throws PathError
         */
        chmod(co: YieldContext, opts: FileChmodAsyncOptions): void
        /**
         * changes the mode of the file to mode
         * @throws PathError
         */
        chmod(opts: FileChmodAsyncOptions): Promise<void>
        /**
         * changes the uid and gid of the file
         * @throws PathError
         */
        chownSync(opts: FileChownSyncOptions): void
        /**
         * Similar to chownSync but called asynchronously, notifying the result in cb
         */
        chown(opts: FileChownOptions, cb: (PathError?: any) => void): void
        /**
         * changes the uid and gid of the file
         * @throws PathError
         */
        chown(co: YieldContext, opts: FileChownOptions): void
        /**
         * changes the uid and gid of the file
         * @throws PathError
         */
        chown(opts: FileChownOptions): Promise<void>
        /**
         * changes the size of the file. It does not change the I/O offset.
         * @throws PathError
         */
        truncateSync(size: number): void
        /**
         * Similar to truncateSync but called asynchronously, notifying the result in cb
         */
        truncate(size: number, cb: (PathError?: any) => void): void
        /**
         * Similar to truncateSync but called asynchronously, notifying the result in cb
         */
        truncate(opts: FileTruncateOptions, cb: (PathError?: any) => void): void
        /**
         * changes the size of the file. It does not change the I/O offset.
         * @throws PathError
         */
        truncate(co: YieldContext, size: number): void
        /**
         * changes the size of the file. It does not change the I/O offset.
         * @throws PathError
         */
        truncate(co: YieldContext, opts: FileTruncateOptions): void
        /**
         * changes the size of the file. It does not change the I/O offset.
         * @throws PathError
         */
        truncate(size: number): Promise<void>
        /**
         * changes the size of the file. It does not change the I/O offset.
         * @throws PathError
         */
        truncate(opts: FileTruncateOptions): Promise<void>

        /**
         * Read the file name in the folder
         * @throws PathError
         * @param n If greater than 0, the maximum length of the returned array is n
         */
        readDirNamesSync(n?: number): Array<string>
        /**
         * Similar to readDirNamesSync but called asynchronously, notifying the result in cb
         */
        readDirNames(cb: (dirs?: Array<string>, PathError?: any) => void): void
        /**
         * Similar to readDirNamesSync but called asynchronously, notifying the result in cb
         */
        readDirNames(n: number, cb: (dirs?: Array<string>, PathError?: any) => void): void
        /**
        * Similar to readDirNamesSync but called asynchronously, notifying the result in cb
        */
        readDirNames(opts: FileReadDirOptions, cb: (dirs?: Array<string>, PathError?: any) => void): void
        /**
         * Read the file name in the folder
         * @throws PathError
        */
        readDirNames(co: YieldContext): Array<string>
        /**
         * Read the file name in the folder
         * @throws PathError
         * @param n If greater than 0, the maximum length of the returned array is n
         */
        readDirNames(co: YieldContext, n: number): Array<string>
        /**
         * Read the file name in the folder
         * @throws PathError
        */
        readDirNames(co: YieldContext, opts: FileReadDirOptions): Array<string>
        /**
         * Read the file name in the folder
         * @throws PathError
        */
        readDirNames(): Promise<Array<string>>
        /**
         * Read the file name in the folder
         * @throws PathError
         * @param n If greater than 0, the maximum length of the returned array is n
         */
        readDirNames(n: number): Promise<Array<string>>
        /**
         * Read the file name in the folder
         * @throws PathError
        */
        readDirNames(opts: FileReadDirOptions): Promise<Array<string>>

        /**
         * Read the file info in the folder
         * @throws PathError
         * @param n If greater than 0, the maximum length of the returned array is n
         */
        readDirSync(n?: number): Array<FileInfo>
        /**
         * Similar to readDirSync but called asynchronously, notifying the result in cb
         */
        readDir(cb: (dirs?: Array<FileInfo>, e?: PathError) => void): void
        /**
         * Similar to readDirSync but called asynchronously, notifying the result in cb
         */
        readDir(n: number, cb: (dirs?: Array<FileInfo>, e?: PathError) => void): void
        /**
         * Similar to readDirSync but called asynchronously, notifying the result in cb
         */
        readDir(opts: FileReadDirOptions, cb: (dirs?: Array<FileInfo>, e?: PathError) => void): void
        /**
         * Read the file info in the folder
         * @throws PathError
         */
        readDir(co: YieldContext): Array<FileInfo>
        /**
         * Read the file info in the folder
         * @throws PathError
         */
        readDir(co: YieldContext, opts: FileReadDirOptions): Array<FileInfo>
        /**
         * Read the file info in the folder
         * @throws PathError
         * @param n If greater than 0, the maximum length of the returned array is n
         */
        readDir(co: YieldContext, n: number): Array<FileInfo>
        /**
         * Read the file info in the folder
         * @throws PathError
         */
        readDir(): Promise<Array<FileInfo>>
        /**
         * Read the file info in the folder
         * @throws PathError
         */
        readDir(opts: FileReadDirOptions): Promise<Array<FileInfo>>
        /**
         * Read the file info in the folder
         * @throws PathError
         * @param n If greater than 0, the maximum length of the returned array is n
         */
        readDir(n: number): Promise<Array<FileInfo>>
    }

    export interface Reader {
        read(opts: ReadOptions | ejs.BufferData, cb: (n?: number, e?: any) => void): void
    }
    /**
     * Continue reading the data in the reader until all is read or cb returns true
     * @returns should we stop reading?
     */
    export function readAll(reader: Reader, opts: ReadOptions | ejs.BufferData, cb: (n?: number, e?: any) => boolean | undefined): void
    export interface StatOptions extends AsyncOptions {
        name: string
    }
    /**
     * returns the FileInfo describing file.
     * @throws PathError
     */
    export function statSync(name: string): FileInfo
    /**
     * Similar to statSync but called asynchronously, notifying the result in cb
     */
    export function stat(name: string, cb: (info?: FileInfo, e?: PathError) => void): void
    /**
     * Similar to statSync but called asynchronously, notifying the result in cb
     */
    export function stat(opts: StatOptions, cb: (info?: FileInfo, e?: PathError) => void): void
    /**
     * returns the FileInfo describing file.
     * @throws PathError
     */
    export function stat(co: YieldContext, name: string): FileInfo
    /**
     * returns the FileInfo describing file.
     * @throws PathError
     */
    export function stat(co: YieldContext, opts: StatOptions): FileInfo
    /**
     * returns the FileInfo describing file.
     * @throws PathError
     */
    export function stat(name: string): Promise<FileInfo>
    /**
     * returns the FileInfo describing file.
     * @throws PathError
     */
    export function stat(opts: StatOptions): Promise<FileInfo>

    /**
     * Return to working directory
     */
    export function cwd(): string
    /**
     * changes the current working directory to the named directory
     * @throws PathError
     */
    export function chdir(path: string): void

    export interface ChmodSyncOptions {
        name: string
        perm: number
    }
    export interface ChmodOptions extends ChmodSyncOptions, AsyncOptions { }
    /**
     * changes the mode of the file to mode
     * @throws PathError
     */
    export function chmodSync(opts: ChmodSyncOptions): void
    /**
     * Similar to chmodSync but called asynchronously, notifying the result in cb
     */
    export function chmod(opts: ChmodOptions, cb: (e?: PathError) => void): void
    /**
     * changes the mode of the file to mode
     * @throws PathError
     */
    export function chmod(co: YieldContext, opts: ChmodSyncOptions): void
    /**
     * changes the mode of the file to mode
     * @throws PathError
     */
    export function chmod(opts: ChmodSyncOptions): Promise<void>

    export interface ChownSyncOptions {
        name: string
        uid: number
        gid: number
    }
    export interface ChownOptions extends ChownSyncOptions, AsyncOptions { }
    /**
     * changes the uid and gid of the file
     * @throws PathError
     */
    export function chownSync(opts: ChownSyncOptions): void
    /**
     * Similar to chownSync but called asynchronously, notifying the result in cb
     */
    export function chown(opts: ChownOptions, cb: (e?: PathError) => void): void
    /**
     * changes the uid and gid of the file
     * @throws PathError
     */
    export function chown(co: YieldContext, opts: ChownOptions): void
    /**
     * changes the uid and gid of the file
     * @throws PathError
     */
    export function chown(opts: ChownOptions): Promise<void>
    export interface TruncateSyncOptions {
        name: string
        size: number
    }
    export interface TruncateOptions extends TruncateSyncOptions, AsyncOptions { }
    /**
     * changes the size of the file
     * @throws PathError
     */
    export function truncateSync(opts: TruncateSyncOptions): void
    /**
     * Similar to truncateSync but called asynchronously, notifying the result in cb
     */
    export function truncate(opts: TruncateOptions, cb: (e?: PathError) => void): void
    /**
     * changes the size of the file
     * @throws PathError
     */
    export function truncate(co: YieldContext, opts: TruncateOptions): void
    /**
     * changes the size of the file
     * @throws PathError
     */
    export function truncate(opts: TruncateOptions): Promise<void>

    export interface ReadFileOptions extends AsyncOptions {
        name: string
    }
    /**
     * Read file contents
     * @throws PathError
     */
    export function readFileSync(name: string): Uint8Array
    /**
     * Similar to readFileSync but called asynchronously, notifying the result in cb
     */
    export function readFile(opts: ReadFileOptions, cb: (data?: Uint8Array, e?: PathError) => void): void
    /**
     * Similar to readFileSync but called asynchronously, notifying the result in cb
     */
    export function readFile(name: string, cb: (data?: Uint8Array, e?: PathError) => void): void
    /**
     * Read file contents
     * @throws PathError
     */
    export function readFile(co: YieldContext, opts: ReadFileOptions): Uint8Array
    /**
     * Read file contents
     * @throws PathError
     */
    export function readFile(co: YieldContext, name: string): Uint8Array
    /**
     * Read file contents
     * @throws PathError
     */
    export function readFile(opts: ReadFileOptions): Promise<Uint8Array>
    /**
     * Read file contents
     * @throws PathError
     */
    export function readFile(name: string): Promise<Uint8Array>

    /**
     * abbreviation for new TextDecoder().decode(readFileSync(name))
     * @throws PathError
     */
    export function readTextFileSync(name: string): string
    /**
     * Similar to readTextFileSync but called asynchronously, notifying the result in cb
     */
    export function readTextFile(opts: ReadFileOptions, cb: (data?: string, e?: PathError) => void): void
    /**
     * Similar to readTextFileSync but called asynchronously, notifying the result in cb
     */
    export function readTextFile(name: string, cb: (data?: string, e?: PathError) => void): void
    /**
     * abbreviation for new TextDecoder().decode(readFile(co, opts))
     * @throws PathError
     */
    export function readTextFile(co: YieldContext, opts: ReadFileOptions): string
    /**
     * abbreviation for new TextDecoder().decode(readFile(co, name))
     * @throws PathError
     */
    export function readTextFile(co: YieldContext, name: string): string
    /**
     * abbreviation for new TextDecoder().decode(readFile(name))
     * @throws PathError
     */
    export function readTextFile(opts: ReadFileOptions): Promise<string>
    /**
     * abbreviation for new TextDecoder().decode(readFile(name))
     * @throws PathError
     */
    export function readTextFile(name: string): Promise<string>

    export interface WriteFileSyncOptions {
        name: string
        data?: Uint8Array
        perm?: number
        /**
         * if true, call fsync after written
         */
        sync?: boolean
    }
    export interface WriteFileOptions extends WriteFileSyncOptions, AsyncOptions { }
    /**
     * Create archive and write data
     * @throws PathError
     */
    export function writeFileSync(opts: WriteFileSyncOptions): void
    /**
     * Similar to writeFileSync but called asynchronously, notifying the result in cb
     */
    export function writeFile(opts: WriteFileOptions, cb: (e?: PathError) => void): void
    /**
     * Create archive and write data
     * @throws PathError
     */
    export function writeFile(co: YieldContext, opts: WriteFileOptions): void
    /**
     * Create archive and write data
     * @throws PathError
     */
    export function writeFile(opts: WriteFileOptions): Promise<void>
    export interface WriteTextFileSyncOptions {
        name: string
        data?: Uint8Array
        perm?: number
        /**
         * if true, call fsync after written
         */
        sync?: boolean
    }
    export interface WriteTextFileOptions extends WriteTextFileSyncOptions, AsyncOptions { }
    /**
     * @throws PathError
     * abbreviation for writeFileSync(opts..data=new TextEncoder().encode(opts.data))
     */
    export function writeTextFileSync(opts: WriteTextFileSyncOptions): void
    /**
     * Similar to writeTextFileSync but called asynchronously, notifying the result in cb
     */
    export function writeTextFile(opts: WriteTextFileOptions, cb: (e?: PathError) => void): void
    /**
     * @throws PathError
     * abbreviation for writeFile(co, opts..data=new TextEncoder().encode(opts.data))
     */
    export function writeTextFile(co: YieldContext, opts: WriteTextFileOptions): void
    /**
     * @throws PathError
     * abbreviation for writeFile(opts..data=new TextEncoder().encode(opts.data))
     */
    export function writeTextFile(opts: WriteTextFileOptions): Promise<void>

    export interface ReadDirSyncOptions {
        name: string
        /**
         * If greater than 0, the maximum length of the returned array is n
         */
        n?: number
    }
    export interface ReadDirOptions extends ReadDirSyncOptions, AsyncOptions { }
    /**
     * Read the file name in the folder
     * @throws PathError
     */
    export function readDirNamesSync(opts: ReadDirSyncOptions): Array<string>
    /**
     * Read the file name in the folder
     * @throws PathError
     */
    export function readDirNamesSync(name: string): Array<string>
    /**
     * Similar to readDirNamesSync but called asynchronously, notifying the result in cb
     */
    export function readDirNames(opts: ReadDirOptions, cb: (dirs?: Array<string>, e?: PathError) => void): void
    /**
     * Similar to readDirNamesSync but called asynchronously, notifying the result in cb
     */
    export function readDirNames(name: string, cb: (dirs?: Array<string>, e?: PathError) => void): void
    /**
     * Read the file name in the folder
     * @throws PathError
     */
    export function readDirNames(co: YieldContext, opts: ReadDirOptions): Array<string>
    /**
     * Read the file name in the folder
     * @throws PathError
     */
    export function readDirNames(co: YieldContext, name: string): Array<string>
    /**
     * Read the file name in the folder
     * @throws PathError
     */
    export function readDirNames(opts: ReadDirOptions): Promise<Array<string>>
    /**
     * Read the file name in the folder
     * @throws PathError
     */
    export function readDirNames(name: string): Promise<Array<string>>

    /**
     * Read the file info in the folder
     * @throws PathError
     */
    export function readDirSync(opts: ReadDirSyncOptions): Array<FileInfo>
    /**
     * Read the file info in the folder
     * @throws PathError
     */
    export function readDirSync(name: string): Array<FileInfo>
    /**
     * Similar to readDirSync but called asynchronously, notifying the result in cb
     */
    export function readDirSync(opts: ReadDirOptions, cb: (dirs?: Array<FileInfo>, e?: PathError) => void): void
    /**
     * Similar to readDirSync but called asynchronously, notifying the result in cb
     */
    export function readDirSync(name: string, cb: (dirs?: Array<FileInfo>, e?: PathError) => void): void
    /**
     * Read the file info in the folder
     * @throws PathError
     */
    export function readDirSync(co: YieldContext, opts: ReadDirOptions): Array<FileInfo>
    /**
     * Read the file info in the folder
     * @throws PathError
     */
    export function readDirSync(co: YieldContext, name: string): Array<FileInfo>
    /**
     * Read the file info in the folder
     * @throws PathError
     */
    export function readDirSync(opts: ReadDirOptions): Promise<Array<FileInfo>>
    /**
     * Read the file info in the folder
     * @throws PathError
     */
    export function readDirSync(name: string): Promise<Array<FileInfo>>


    export interface ReadLinkOptions extends AsyncOptions {
        name: string
    }
    /**
     * returns the destination of the named symbolic link
     * @throws PathError
     */
    export function readLinkSync(name: string): string

    /**
     * Similar to readLinkSync but called asynchronously, notifying the result in cb
     */
    export function readLink(opts: ReadLinkOptions, cb: (path?: string, e?: PathError) => void): void
    /**
     * Similar to readLinkSync but called asynchronously, notifying the result in cb
     */
    export function readLink(name: string, cb: (path?: string, e?: PathError) => void): void
    /**
     * returns the destination of the named symbolic link
     * @throws PathError
     */
    export function readLink(co: YieldContext, opts: ReadLinkOptions): string
    /**
     * returns the destination of the named symbolic link
     * @throws PathError
     */
    export function readLink(co: YieldContext, name: string): string
    /**
     * returns the destination of the named symbolic link
     * @throws PathError
     */
    export function readLink(opts: ReadLinkOptions): Promise<string>
    /**
     * returns the destination of the named symbolic link
     * @throws PathError
     */
    export function readLink(name: string): Promise<string>


    export interface RenameSyncOptions {
        from: string
        to: string
    }
    export interface RenameOptions extends RenameSyncOptions, AsyncOptions { }
    /**
     *  renames (moves) opts.from to opts.to
     * @throws LinkError
     */
    export function renameSync(opts: RenameSyncOptions): void
    /**
     *  Similar to renameSync but called asynchronously, notifying the result in cb
     */
    export function rename(opts: RenameOptions, cb: (LinkError?: any) => void): void
    /**
     *  renames (moves) opts.from to opts.to
     * @throws LinkError
     */
    export function rename(co: YieldContext, opts: RenameOptions): void
    /**
     *  renames (moves) opts.from to opts.to
     * @throws LinkError
     */
    export function rename(opts: RenameOptions): Promise<void>

    export interface RemoveSyncOptions {
        name: string
        all?: boolean
    }
    export interface RemoveOptions extends RemoveSyncOptions, AsyncOptions { }
    /**
     * removes the named file or directory
     * @throws PathError
     */
    export function removeSync(opts: RemoveSyncOptions): void
    /**
     * removes the named file or directory
     * @throws PathError
     */
    export function removeSync(name: string): void
    /**
     *  Similar to removeSync but called asynchronously, notifying the result in cb
     */
    export function remove(opts: RemoveOptions, cb: (e?: PathError) => void): void
    /**
     *  Similar to removeSync but called asynchronously, notifying the result in cb
     */
    export function remove(name: string, cb: (e?: PathError) => void): void
    /**
     * removes the named file or directory
     * @throws PathError
     */
    export function remove(co: YieldContext, opts: RemoveOptions): void
    /**
     * removes the named file or directory
     * @throws PathError
     */
    export function remove(co: YieldContext, name: string): void
    /**
     * removes the named file or directory
     * @throws PathError
     */
    export function remove(opts: RemoveOptions): Promise<void>
    /**
     * removes the named file or directory
     * @throws PathError
     */
    export function remove(name: string): Promise<void>

    export interface LinkSyncOptions {
        from: string
        to: string
        hard?: boolean
    }
    export interface LinkOptions extends LinkSyncOptions, AsyncOptions { }
    /**
     * creates opts.to as a link to the opts.from file.
     * @throws LinkError
     */
    export function linkSync(opts: LinkSyncOptions): void
    /**
     *  Similar to linkSync but called asynchronously, notifying the result in cb
     */
    export function link(opts: LinkSyncOptions, cb: (e?: LinkError) => void): void
    /**
     * creates opts.to as a link to the opts.from file.
     * @throws LinkError
     */
    export function link(co: YieldContext, opts: LinkSyncOptions): void
    /**
     * creates opts.to as a link to the opts.from file.
     * @throws LinkError
     */
    export function link(opts: LinkSyncOptions): Promise<void>
    /**
     * returns the default directory to use for temporary files
     */
    export function tempDir(): string | undefined
    /**
     * returns the current user's home directory.
     * 
     * On Unix, including macOS, it returns the $HOME environment variable.
     * On Windows, it returns %USERPROFILE%.
     * On Plan 9, it returns the $home environment variable.
     * 
     * If the expected variable is not set in the environment, userHomeDir
     * returns either a platform-specific default value or a undefined
     */
    export function userHomeDir(): string | undefined
    /**
     * returns the default root directory to use for user-specific
     * configuration data. Users should create their own application-specific
     * subdirectory within this one and use that.
     * 
     * On Unix systems, it returns $XDG_CONFIG_HOME as specified by
     * https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html if
     * non-empty, else $HOME/.config.
     * On Darwin, it returns $HOME/Library/Application Support.
     * On Windows, it returns %AppData%.
     * On Plan 9, it returns $home/lib.
     * 
     * If the location cannot be determined (for example, $HOME is not defined),
     * then it will return a undefined
     */
    export function userConfigDir(): string

    /**
     * returns the default root directory to use for user-specific
     * cached data. Users should create their own application-specific subdirectory
     * within this one and use that.
     * 
     * On Unix systems, it returns $XDG_CACHE_HOME as specified by
     * https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html if
     * non-empty, else $HOME/.cache.
     * On Darwin, it returns $HOME/Library/Caches.
     * On Windows, it returns %LocalAppData%.
     * On Plan 9, it returns $home/lib/cache.
     * 
     * If the location cannot be determined (for example, $HOME is not defined),
     * then it will return a undefined
     */
    export function userCacheDir(): string

    /**
     *  returns the numeric user id of the caller.
     * 
     * On Windows, it returns -1.
     */
    export function getuid(): number
    /**
     *  returns the numeric effective user id of the caller.
     * 
     * On Windows, it returns -1.
     */
    export function geteuid(): number

    /**
     *  returns the numeric group id of the caller.
     * 
     * On Windows, it returns -1.
     */
    export function getgid(): number
    /**
     *  returns the numeric effective group id of the caller.
     * 
     * On Windows, it returns -1.
     */
    export function getegid(): number

    /**
     * returns a list of the numeric ids of groups that the caller belongs to.
     * 
     * On Windows, it returns []
     */
    export function getgroups(): Array<number>

    /**
     * returns a copy of strings representing the environment, in the form "key=value".
     */
    export function environ(): Array<string>
    /**
     * deletes all environment variables.
     */
    export function clearenv(): void
    /**
     *  sets the value of the environment variable named by the key
     */
    export function setenv(key: string, value: string, replace = true): void
    /**
     *  unsets a single environment variable
     */
    export function unsetenv(key: string): void

    /**
     * etrieves the value of the environment variable named by the key
     */
    export function getenv(key: string): string | undefined

    /**
     * removes the named empty directory
     * @throws PathError
     */
    export function rmdirSync(name: string): void
    /**
     * removes the named empty directory
     * @throws PathError
     */
    export function rmdirSync(opts: RemoveSyncOptions): void
    /**
     *  Similar to rmdirSync but called asynchronously, notifying the result in cb
     */
    export function rmdir(name: string, cb: (e?: PathError) => void): void
    /**
     *  Similar to rmdirSync but called asynchronously, notifying the result in cb
     */
    export function rmdir(opts: RemoveOptions, cb: (e?: PathError) => void): void
    /**
     * removes the named empty directory
     * @throws PathError
     */
    export function rmdir(co: YieldContext, name: string): void
    /**
     * removes the named empty directory
     * @throws PathError
     */
    export function rmdir(co: YieldContext, opts: RemoveOptions): void
    /**
     * removes the named empty directory
     * @throws PathError
     */
    export function rmdir(name: string): Promise<void>
    /**
     * removes the named empty directory
     * @throws PathError
     */
    export function rmdir(opts: RemoveOptions): Promise<void>

    export interface MkdirSyncOptions {
        name: string
        /**
         * @default 0o775
         */
        perm?: number
        /**
         * @default false
         */
        all?: boolean
    }
    export interface MkdirOptions extends MkdirSyncOptions, AsyncOptions { }
    /**
     * creates a directory named opts.name
     * @throws PathError
     */
    export function mkdirSync(name: string): void
    /**
     * creates a directory named opts.name
     * @throws PathError
     */
    export function mkdirSync(opts: MkdirSyncOptions): void
    /**
     *  Similar to mkdirSync but called asynchronously, notifying the result in cb
     */
    export function mkdir(name: string, cb: (e?: PathError) => void): void
    /**
     *  Similar to mkdirSync but called asynchronously, notifying the result in cb
     */
    export function mkdir(opts: MkdirOptions, cb: (e?: PathError) => void): void
    /**
     * creates a directory named opts.name
     * @throws PathError
     */
    export function mkdir(co: YieldContext, name: string): void
    /**
     * creates a directory named opts.name
     * @throws PathError
     */
    export function mkdir(co: YieldContext, opts: MkdirOptions): void
    /**
     * creates a directory named opts.name
     * @throws PathError
     */
    export function mkdir(name: string): Promise<void>
    /**
     * creates a directory named opts.name
     * @throws PathError
     */
    export function mkdir(opts: MkdirOptions): Promise<void>

    export interface MkdirTempSyncOptions {
        pattern: string
        /**
         * @default tempDir()
         */
        dir?: string

        /**
         * @default 0o700
         */
        perm?: number
    }
    export interface MkdirTempOptions extends MkdirTempSyncOptions, AsyncOptions { }
    /**
     * creates a new temporary directory
     * @throws PathError
     */
    export function mkdirTempSync(pattern: string): string
    /**
     * creates a new temporary directory
     * @throws PathError
     */
    export function mkdirTempSync(opts: MkdirTempSyncOptions): string
    /**
     *  Similar to mkdirTempSync but called asynchronously, notifying the result in cb
     */
    export function mkdirTemp(pattern: string, cb: (dir?: string, e?: PathError) => void): void
    /**
     *  Similar to mkdirTempSync but called asynchronously, notifying the result in cb
     */
    export function mkdirTemp(opts: MkdirTempOptions, cb: (dir?: string, e?: PathError) => void): void
    /**
     * creates a new temporary directory
     * @throws PathError
     */
    export function mkdirTemp(co: YieldContext, pattern: string): string
    /**
     * creates a new temporary directory
     * @throws PathError
     */
    export function mkdirTemp(co: YieldContext, opts: MkdirTempOptions): string
    /**
     * creates a new temporary directory
     * @throws PathError
     */
    export function mkdirTemp(pattern: string): Promise<string>
    /**
     * creates a new temporary directory
     * @throws PathError
     */
    export function mkdirTemp(opts: MkdirTempOptions): Promise<string>
}
/**
 * URL processing module ported from golang standard library
 */
declare module "ejs/net/url" {
    export class EscapeError extends Error {
        constructor(message: string, opts?: any)
    }
    export class InvalidHostError extends Error {
        constructor(message: string, opts?: any)
    }
    /**
     * queryUnescape does the inverse transformation of queryEscape,
     * converting each 3-byte encoded substring of the form "%AB" into the
     * hex-decoded byte 0xAB.
     * It returns an error if any % is not followed by two hexadecimal
     * digits.
     * @throws EscapeError OsErrror Errror
     */
    export function queryUnescape(s: string): string
    /**
     * pathUnescape does the inverse transformation of pathEscape,
     * converting each 3-byte encoded substring of the form "%AB" into the
     * hex-decoded byte 0xAB. It returns an error if any % is not followed
     * by two hexadecimal digits.
     * 
     * pathUnescape is identical to queryUnescape except that it does not
     * unescape '+' to ' ' (space).
     * @throws EscapeError OsErrror Errror
     */
    export function pathUnescape(s: string): string

    /**
     * escapes the string so it can be safely placed
     * inside a URL query.
     */
    export function queryEscape(s: string): string
    /**
     * escapes the string so it can be safely placed inside a URL path segment,
     * replacing special characters (including /) with %XX sequences as needed.
     */
    export function pathEscape(s: string): string

    /**
     * The Userinfo class is an immutable encapsulation of username and
     * password details for a URL. An existing Userinfo value is guaranteed
     * to have a username set (potentially empty, as allowed by RFC 2396),
     * and optionally a password.
     */
    export class Userinfo {
        constructor(readonly username: string, readonly password?: string | null)
        toString(): string
    }
    /**
     * Values maps a string key to a list of values.
     * It is typically used for query parameters and form values.
     * Unlike in the http.Header map, the keys in a Values map
     * are case-sensitive.
     */
    export class Values {
        /**
         * Parses the URL-encoded query string and returns
         * the values specified for each key.
         * 
         * Query is expected to be a list of key=value settings separated by ampersands.
         * A setting without an equals sign is interpreted as a key set to an empty value.
         * Settings containing a non-URL-encoded semicolon are considered invalid.
         */
        static parse(query: string, ignoeInvalid?: boolean): Values

        readonly values: Record<string, Array<string> | undefined>
        constructor(values?: Record<string, Array<string> | undefined>)
        /**
         * Gets the first value associated with the given key.
         * If there are no values associated with the key, Get returns
         * undefined. To access multiple values, use the record
         * directly.
         */
        get(key: string): string | undefined
        /**
         * Sets the key to value. It replaces any existing values
         */
        set(key: string, value: any): void
        /**
         * Adds the value to key. It appends to any existing
         * values associated with key.
         */
        add(key: string, value: any): void
        /**
         * Deletes the values associated with key.
         * @param logic If true, just set the property to undefined; if false, delete is called.
         */
        remove(key: string, logic?: boolean): void
        /**
         * checks whether a given key is set
         */
        has(key: string): boolean
        /**
         * encodes the values into “URL encoded” form ("bar=baz&foo=quux") sorted by key.
         */
        encode(): string
    }
    export interface URLOptions {
        scheme?: string
        /**
         * encoded opaque data
         */
        opaque?: string
        /**
         * username and password information
         */
        user?: {
            username?: string
            password?: string
        }
        /**
         * host or host:port
         */
        host?: string
        /**
         * path (relative paths may omit leading slash)
         */
        path?: string
        /**
         * encoded path hint (see escapedPath method)
         */
        rawPath?: string
        /**
         * do not emit empty host (authority)
         */
        omitHost?: boolean
        /**
         * append a query ('?') even if rawQuery is empty
         */
        forceQuery?: boolean
        /**
         * encoded query values, without '?'
         */
        rawQuery?: string
        /**
         * fragment for references, without '#'
         */
        fragment?: string
        /**
         *  encoded fragment hint (see EscapedFragment method)
         */
        rawFragment?: string
    }
    /**
     * A URL represents a parsed URL (technically, a URI reference).
     * 
     * The general form represented is:
     * 
     * [scheme:][//[userinfo@]host][/]path[?query][#fragment]
     * 
     * URLs that do not start with a slash after the scheme are interpreted as:
     * 
     * scheme:opaque[?query][#fragment]
     * 
     * Note that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/.
     * A consequence is that it is impossible to tell which slashes in the Path were
     * slashes in the raw URL and which were %2f. This distinction is rarely important,
     * but when it is, the code should use the escapedPath method, which preserves
     * the original encoding of path.
     * 
     * The rawPath field is an optional field which is only set when the default
     * encoding of path is different from the escaped path. See the escapedPath method
     * for more details.
     * 
     * URL's String method uses the escapedPath method to obtain the path.
     */
    export class URL {
        static parse(rawURL: string, requestURI?: boolean): URL
        clone(): URL
        constructor(o?: URLOptions)

        scheme: string
        /**
         * encoded opaque data
         */
        opaque: string
        /**
         * username and password information
         */
        user?: Userinfo
        /**
         * host or host:port
         */
        host: string
        /**
         * path (relative paths may omit leading slash)
         */
        path: string
        /**
         * encoded path hint (see escapedPath method)
         */
        rawPath: string
        /**
         * do not emit empty host (authority)
         */
        omitHost = false
        /**
         * append a query ('?') even if rawQuery is empty
         */
        forceQuery = false
        /**
         * encoded query values, without '?'
         */
        rawQuery: string
        /**
         * fragment for references, without '#'
         */
        fragment: string
        /**
         *  encoded fragment hint (see EscapedFragment method)
         */
        rawFragment: string
        /**
         * EscapedFragment returns the escaped form of URL.fragment.
         * In general there are multiple possible escaped forms of any fragment.
         * EscapedFragment returns URL.rawFragment when it is a valid escaping of URL.fragment.
         * Otherwise escapedFragment ignores URL.rawFragment and computes an escaped
         * form on its own.
         * The toString method uses escapedFragment to construct its result.
         * In general, code should call escapedFragment instead of
         * reading URL.rawFragment directly.
         */
        escapedFragment(): string
        /**
         * EscapedPath returns the escaped form of URL.path.
         * In general there are multiple possible escaped forms of any path.
         * EscapedPath returns URL.rawPath when it is a valid escaping of URL.path.
         * Otherwise escapedPath ignores URL.rawPath and computes an escaped
         * form on its own.
         * The toString and requestURI methods use escapedPath to construct
         * their results.
         * In general, code should call escapedPath instead of
         * reading URL.rawPath directly.
         */
        escapedPath(): string
        /**
         * Returns URL.host, stripping any valid port number if present.
         * 
         * If the result is enclosed in square brackets, as literal IPv6 addresses are,
         * the square brackets are removed from the result.
         */
        hostname(): string
        /**
         * Returns the port part of URL.host, without the leading colon.
         * 
         * If URL.host doesn't contain a valid numeric port, Port returns an empty string.
         */
        port(): string
        /**
         * Reports whether the URL is absolute.
         * Absolute means that it has a non-empty scheme.
         */
        isAbs(): boolean
        /**
         * JoinPath returns a new URL with the provided path elements joined to
         * any existing path and the resulting path cleaned of any ./ or ../ elements.
         * Any sequences of multiple / characters will be reduced to a single /.
         */
        joinPathArray(elem: Array<string>): URL
        /**
         * JoinPath returns a new URL with the provided path elements joined to
         * any existing path and the resulting path cleaned of any ./ or ../ elements.
         * Any sequences of multiple / characters will be reduced to a single /.
         */
        joinPath(...elem: Array<string>): URL
        /**
         * Query parses rawQuery and returns the corresponding values.
         * It silently discards malformed value pairs.
         * To check errors use Values.parse.
         */
        query(ignoeInvalid?: boolean): Values
        /**
         * Redacted is like String but replaces any password with "xxxxx".
         * Only the password in URL.user is redacted.
         */
        redacted(): string
        /**
         * Returns the encoded path?query or opaque?query
         * string that would be used in an HTTP request for u.
         */
        requestURI(): string
        /**
         * Resolves a URI reference to an absolute URI from
         * an absolute base URI u, per RFC 3986 Section 5.2. The URI reference
         * may be relative or absolute. ResolveReference always returns a new
         * URL instance, even if the returned URL is identical to either the
         * base or reference. If ref is an absolute URL, then ResolveReference
         * ignores base and returns a copy of ref.
         */
        resolveReference(refer: URL | string): URL
        toString(): string
    }
    /**
     * eturns a URL string with the provided path elements joined to
     * the existing path of base and the resulting path cleaned of any ./ or ../ elements.
     */
    export function joinPath(base: string, ...elem: Array<string>): string
    /**
     * eturns a URL string with the provided path elements joined to
     * the existing path of base and the resulting path cleaned of any ./ or ../ elements.
     */
    export function joinPathArray(base: string, elem: Array<string>): string
}

/**
 * Wrap the http provided by libevent into js
 */
declare module "ejs/net/http" {
    import { BaseTcpListener } from "ejs/net";
    import { YieldContext } from "ejs/sync";

    export enum Method {
        GET = 1,
        POST = 2,
        HEAD = 4,
        PUT = 8,
        DELETE = 16,
        OPTIONS = 32,
        TRACE = 64,
        CONNECT = 128,
        PATCH = 256,
    }

    export const StatusContinue = 100 // RFC 9110, 15.2.1
    export const StatusSwitchingProtocols = 101 // RFC 9110, 15.2.2
    export const StatusProcessing = 102 // RFC 2518, 10.1
    export const StatusEarlyHints = 103 // RFC 8297

    export const StatusOK = 200 // RFC 9110, 15.3.1
    export const StatusCreated = 201 // RFC 9110, 15.3.2
    export const StatusAccepted = 202 // RFC 9110, 15.3.3
    export const StatusNonAuthoritativeInfo = 203 // RFC 9110, 15.3.4
    export const StatusNoContent = 204 // RFC 9110, 15.3.5
    export const StatusResetContent = 205 // RFC 9110, 15.3.6
    export const StatusPartialContent = 206 // RFC 9110, 15.3.7
    export const StatusMultiStatus = 207 // RFC 4918, 11.1
    export const StatusAlreadyReported = 208 // RFC 5842, 7.1
    export const StatusIMUsed = 226 // RFC 3229, 10.4.1

    export const StatusMultipleChoices = 300 // RFC 9110, 15.4.1
    export const StatusMovedPermanently = 301 // RFC 9110, 15.4.2
    export const StatusFound = 302 // RFC 9110, 15.4.3
    export const StatusSeeOther = 303 // RFC 9110, 15.4.4
    export const StatusNotModified = 304 // RFC 9110, 15.4.5
    export const StatusUseProxy = 305 // RFC 9110, 15.4.6
    // _                       = 306 // RFC 9110, 15.4.7 (Unused)
    export const StatusTemporaryRedirect = 307 // RFC 9110, 15.4.8
    export const StatusPermanentRedirect = 308 // RFC 9110, 15.4.9

    export const StatusBadRequest = 400 // RFC 9110, 15.5.1
    export const StatusUnauthorized = 401 // RFC 9110, 15.5.2
    export const StatusPaymentRequired = 402 // RFC 9110, 15.5.3
    export const StatusForbidden = 403 // RFC 9110, 15.5.4
    export const StatusNotFound = 404 // RFC 9110, 15.5.5
    export const StatusMethodNotAllowed = 405 // RFC 9110, 15.5.6
    export const StatusNotAcceptable = 406 // RFC 9110, 15.5.7
    export const StatusProxyAuthRequired = 407 // RFC 9110, 15.5.8
    export const StatusRequestTimeout = 408 // RFC 9110, 15.5.9
    export const StatusConflict = 409 // RFC 9110, 15.5.10
    export const StatusGone = 410 // RFC 9110, 15.5.11
    export const StatusLengthRequired = 411 // RFC 9110, 15.5.12
    export const StatusPreconditionFailed = 412 // RFC 9110, 15.5.13
    export const StatusRequestEntityTooLarge = 413 // RFC 9110, 15.5.14
    export const StatusRequestURITooLong = 414 // RFC 9110, 15.5.15
    export const StatusUnsupportedMediaType = 415 // RFC 9110, 15.5.16
    export const StatusRequestedRangeNotSatisfiable = 416 // RFC 9110, 15.5.17
    export const StatusExpectationFailed = 417 // RFC 9110, 15.5.18
    export const StatusTeapot = 418 // RFC 9110, 15.5.19 (Unused)
    export const StatusMisdirectedRequest = 421 // RFC 9110, 15.5.20
    export const StatusUnprocessableEntity = 422 // RFC 9110, 15.5.21
    export const StatusLocked = 423 // RFC 4918, 11.3
    export const StatusFailedDependency = 424 // RFC 4918, 11.4
    export const StatusTooEarly = 425 // RFC 8470, 5.2.
    export const StatusUpgradeRequired = 426 // RFC 9110, 15.5.22
    export const StatusPreconditionRequired = 428 // RFC 6585, 3
    export const StatusTooManyRequests = 429 // RFC 6585, 4
    export const StatusRequestHeaderFieldsTooLarge = 431 // RFC 6585, 5
    export const StatusUnavailableForLegalReasons = 451 // RFC 7725, 3

    export const StatusInternalServerError = 500 // RFC 9110, 15.6.1
    export const StatusNotImplemented = 501 // RFC 9110, 15.6.2
    export const StatusBadGateway = 502 // RFC 9110, 15.6.3
    export const StatusServiceUnavailable = 503 // RFC 9110, 15.6.4
    export const StatusGatewayTimeout = 504 // RFC 9110, 15.6.5
    export const StatusHTTPVersionNotSupported = 505 // RFC 9110, 15.6.6
    export const StatusVariantAlsoNegotiates = 506 // RFC 2295, 8.1
    export const StatusInsufficientStorage = 507 // RFC 4918, 11.5
    export const StatusLoopDetected = 508 // RFC 5842, 7.2
    export const StatusNotExtended = 510 // RFC 2774, 7
    export const StatusNetworkAuthenticationRequired = 511 // RFC 6585, 6

    /**
     * Returns the text description corresponding to the http status code
     */
    export function statusText(code: number): string
    export const ContentTypeHTML = "text/html; charset=utf-8"
    export const ContentTypeText = "text/plain; charset=utf-8"
    export const ContentTypeJSON = "application/json; charset=utf-8"
    export const ContentTypeJSONP = "application/javascript; charset=utf-8"
    export const ContentTypeXML = "application/xml; charset=utf-8"
    export const ContentTypeYAML = "application/yaml; charset=utf-8"

    /**
     * The request uri received by the server
     */
    export class Uri {
        private constructor()
        get fragment(): string
        get host(): string
        get port(): string
        get path(): string
        get query(): string
        get scheme(): string
        get userinfo(): string
        toString(): string
    }
    /**
     * The request received by the server
    */
    export class Request {
        private constructor()
        /**
         * Whether the request is valid. If a request expires and continues to call other member functions, an exception will be thrown.
         */
        readonly isValid: boolean
        /**
         * The host name the request received
         */
        get host(): string
        /**
         * The request uri received by the server
         */
        get uri(): Uri
        /**
         * Returns the internal method enumeration value
         */
        get method(): number
        /**
         * Returns the standard method string
         */
        get methodString(): string | undefined
        /**
         * Return http request header
         */
        get header(): Header
    }
    /**
     * Return http request header
     */
    export class Header {
        private constructor()
        /**
         * Whether the header is valid. If an header expires and continues to call other member functions, an exception will be thrown.
         */
        readonly isValid: boolean
        /**
         * set an header 
         */
        set(key: string, value?: any): void
        /**
         * add an heaer 
         */
        add(key: string, value?: any): void
        /**
         * Returns the value of the first key found
         */
        value(key: string): string | undefined
        /**
         * Returns all values ​​found for key
         */
        values(key: string): Array<string> | undefined
        /**
         * Delete the value of the first key found
         */
        remove(key: string): void
        /**
         * Delete the value of all found keys
         */
        removeAll(key: string): void
        /**
         * Clear all headers
         */
        clear(): void
        /**
         * Traverse headers. If true is returned, stop traversing.
         */
        forEach(f: (k: string, v: string) => boolean | undefined): void
    }
    /**
     * Used by http servers to write responses to requests
     */
    export class ResponseWriter {
        private constructor()
        // close(): void

        /**
         * Return the header to be responded to
         */
        header(): Header
        /**
         * Syntactic sugar for .header().add(key, value)
         */
        header(key: string, value?: any): void

        /**
         * Complete http response with code
         */
        status(code: number): void
        /**
         * Use code to complete the http response and write the body at the same time
         * @param code http response code
         * @param contentType content type of body
         * @param body response body
         */
        body(code: number, contentType: string, body: string | ejs.BufferData): void
        /**
         * Syntactic sugar for .body(code, ContentTypeText, body)
         */
        text(code: number, body: string | ejs.BufferData): void
        /**
         * Syntactic sugar for .body(code, ContentTypeJSON, JSON.stringify(body, replacer, space))
         */
        json(code: number, body: any, replacer?: (number | string)[] | null, space?: string | number): void
        /**
         * Syntactic sugar for .body(code, ContentTypeJSONP, `${callback}(${JSON.stringify(body, replacer, space)})`)
         */
        jsonp(code: number, callback: string, body: any, replacer?: (number | string)[] | null, space?: string | number): void

        /**
         * Response with code Request to return the body in chunks
         */
        chunk(code: number): ChunkWriter

        /**
         * If the request is a websocket request, return the websocket server implementation, otherwise do nothing and return undefined
         */
        upgrade(): Websocket | undefined
    }
    /**
     * Implement http chunked response
     */
    export class ChunkWriter {
        private constructor()
        /**
         * Write a chunked data to the buffer, You need to wait for a write to complete before writing the next chunk
         * @param data What to write
         * @param cb Callback after content is written
         */
        chunk(data: string | ejs.BufferData, cb: () => void): void
        /**
         * Write a chunked data to the buffer, You need to wait for a write to complete before writing the next chunk
         * @param co Context used for the coroutine to give up the CPU
         * @param data What to write
         */
        chunk(co: YieldContext, data: string | ejs.BufferData): void
        /**
         * Write a chunked data to the buffer, You need to wait for a write to complete before writing the next chunk
         * @param data What to write
         */
        chunk(data: string | ejs.BufferData): Promise<void>
        /**
         * Close the response stream to complete the response
         */
        close(): void
    }
    /**
     * http handler interface
     */
    export interface Handler {
        serveHTTP(w: ResponseWriter, r: Request): void
    }
    /**
     * http server
     */
    export class Server {
        /**
         * 
         * @param listener tcp compatible listener
         * @param h http request handler
         */
        constructor(readonly listener: BaseTcpListener,
            h: Handler,
        )
        /**
         * Stopping the service will not block existing requests
         */
        close(): void
    }
    /**
     * Wrap a function as an handler
     */
    export function handlerFunc(f: (w: ResponseWriter, r: Request) => void): Handler
    export function error(w: ResponseWriter, error: string, code: number): void
    export function notFound(w: ResponseWriter, r?: Request): void
    export function notFoundHandler(): Handler
    export function redirect(w: ResponseWriter, r: Request, url: string, code: number): void

    interface MuxEntry {
        pattern: string
        h: Handler
    }
    /**
     * ServeMux is an HTTP request multiplexer.
     * It matches the URL of each incoming request against a list of registered
     * patterns and calls the handler for the pattern that
     * most closely matches the URL.
     */
    export class ServeMux implements Handler {
        handler(r: Request): MuxEntry
        serveHTTP(w: ResponseWriter, r: Request): void
        handle(pattern: string, handler: Handler): void
        handle(pattern: string, handler: (w: ResponseWriter, r: Request) => void): void
    }
    export interface WebsocketOptions extends HttpClientOptions {
        limit?: number
        path?: string
        header?: Record<string, string | Array<string>>
        signal?: AbortSignal
    }
    /**
     * Implemented websocket server and client
     */
    export class Websocket {
        /**
         * Create an http connection
         */
        static connect(opts: WebsocketOptions, cb: (ws?: Websocket, e?: unknown) => void): void
        /**
         * Create an http connection
         */
        static connect(co: YieldContext, opts: WebsocketOptions): Websocket
        /**
         * Create an http connection
         */
        static connect(opts: WebsocketOptions): Promise<Websocket>

        private constructor()
        /**
         * Send a text frame or binary frame
         * @param data What to send
         */
        write(data: string | ejs.BufferData): void
        /**
         * There is no need to explicitly call this function unless you want to disconnect immediately.
         */
        close(): void
        /**
         * When the connection is disconnected, the system will call this function. You don't need to explicitly call this.close() inside
         */
        onClose?: (this: Websocket) => void
        /**
         * This function is called when a text frame or binary frame is received. If it is undefined, receiving data will be paused
         */
        onMessage?: (this: Websocket, data: string | Uint8Array) => void
    }

    export interface RequestOptions {
        limit?: number
        path?: string
        method?: Method
        header?: Record<string, string | Array<string>>
        body?: string | Uint8Array | ArrayBuffer
        signal?: AbortSignal
    }
    export class Response {
        private constructor()
        /**
         * Releases all resources immediately, usually you don't need to explicitly call it
         */
        close(): void
        /**
         * Is it still valid? If it is invalid, calling other functions will throw an exception.
         */
        readonly isValid: boolean
        /**
         * http respone code
         */
        get statusCode(): number
        /**
         * code string name
         */
        get status(): string
        /**
         * response header
         */
        get header(): Header
        /**
         * response body
         */
        body(): Uint8Array
        /**
         * return new TextDecoder().decode(this.body())
         */
        text(): string
        /**
         * return JSON.parse(this.text())
         */
        json<T>(): T
    }
    export interface HttpClientOptions {
        /**
         * Default Host set for http header
         */
        host?: string
        /**
         * string form of address (for example, "192.0.2.1:25", "[2001:db8::1]:80")
         */
        address: string
        /**
         * Domain name resolver
         */
        resolver?: Resolver
        /**
         * tls setting, if it exists, send https request, otherwise send http request
         */
        tls?: TlsConfig
    }
    /**
     * An http client. It automatically creates the connection and you don't have to manage the connection
     */
    export class HttpClient {
        constructor(opts: HttpClientOptions)
        /**
         * Close the client to release all resources
         */
        close(): void
        /**
         * Send an http request. This will throw an exception if the previous request has not completed yet.
         */
        do(req: RequestOptions, cb: (resp?: Response, e?: unknown) => void): void
        /**
         * Send an http request.
         */
        do(req: RequestOptions): Promise<Response>
        /**
         * Send an http request. This will throw an exception if the previous request has not completed yet.
         */
        do(co: YieldContext, req: RequestOptions): Response
    }
}